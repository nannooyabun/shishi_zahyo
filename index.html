<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>ã‚²ãƒ¼ãƒ åº§æ¨™ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ </title>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
            overscroll-behavior: none;
        }
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            text-align: center;
        }
        .header h1 {
            font-size: 28px;
            margin-bottom: 8px;
        }
        @media (max-width: 768px) {
            .header h1 {
                font-size: 20px;
            }
            .header p {
                font-size: 13px;
            }
        }
        .main-content {
            display: grid;
            grid-template-columns: 30% 70%;
            gap: 20px;
            padding: 20px;
        }
        
        /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ: å·¦ã‚«ãƒ©ãƒ ã¨å³ã‚«ãƒ©ãƒ  */
        .left-column {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .right-column {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* å³ã‚«ãƒ©ãƒ å†…ã®ä¸‹éƒ¨2ã‚«ãƒ©ãƒ ä¸¦åˆ—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */
        .bottom-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–: ã‚¹ãƒãƒ›ã§ã¯1ã‚«ãƒ©ãƒ ã« */
        @media (max-width: 768px) {
            .main-content {
                display: flex;
                flex-direction: column;
                padding: 10px;
            }
            .bottom-row {
                grid-template-columns: 1fr;
            }
        }

        /* ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆç¸¦å‘ã: ã‚°ãƒ«ãƒ¼ãƒ—ç®¡ç†ã¨ä¿å­˜æ¸ˆã¿åº§æ¨™ã‚’1ã‚«ãƒ©ãƒ ã« */
        @media (max-aspect-ratio: 1/1) and (min-width: 769px) {
            .bottom-row {
                grid-template-columns: 1fr;
            }
        }
        .section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        @media (max-width: 768px) {
            .section {
                padding: 15px;
                margin-bottom: 15px;
            }
        }
        .section h2 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #333;
        }
        /* æ“ä½œã‚¬ã‚¤ãƒ‰ã‚¹ã‚¿ã‚¤ãƒ« */
        .guide-section {
            background: #f8f9fa;
        }
        .guide-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            margin-bottom: 10px;
            padding: 0;
            overflow: hidden;
        }
        .guide-item summary {
            cursor: pointer;
            padding: 12px 15px;
            font-weight: bold;
            color: #667eea;
            user-select: none;
            list-style: none;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            transition: all 0.2s;
        }
        .guide-item summary::-webkit-details-marker {
            display: none;
        }
        .guide-item summary:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
        }
        .guide-item summary::before {
            content: 'â–¶';
            display: inline-block;
            margin-right: 8px;
            transition: transform 0.2s;
        }
        .guide-item[open] summary::before {
            transform: rotate(90deg);
        }
        .guide-content {
            padding: 15px;
            border-top: 1px solid #e0e0e0;
            line-height: 1.6;
        }
        .guide-content p {
            margin-bottom: 10px;
        }
        .guide-content ul, .guide-content ol {
            margin-left: 20px;
            margin-bottom: 10px;
        }
        .guide-content li {
            margin-bottom: 5px;
        }
        .guide-content code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #d63384;
        }
        .guide-content strong {
            color: #495057;
        }
        @media (max-width: 768px) {
            .guide-content {
                padding: 12px;
                font-size: 14px;
            }
        }
        /* å…¨ç”»é¢è¡¨ç¤ºã‚¹ã‚¿ã‚¤ãƒ« */
        .fullscreen-container {
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw !important;
            max-height: 100vh !important;
            overflow: hidden;
            background: white;
            margin: 0;
            padding: 0;
        }
        .fullscreen-container .section {
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            margin: 0;
            padding: 0;
            border-radius: 0;
        }
        .fullscreen-container canvas {
            flex: 1;
            width: 100% !important;
            height: 100% !important;
            max-width: 100vw !important;
            max-height: 100vh !important;
        }
        .fullscreen-container .map-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .fullscreen-container .mode-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .fullscreen-container .grid-display {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        /* ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ï¼ˆé€šå¸¸è¡¨ç¤ºæ™‚ï¼‰ */
        .map-section {
            position: relative;
        }
        .floating-controls .map-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .floating-controls .mode-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .floating-controls .grid-display {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        textarea {
            width: 100%;
            min-height: 200px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-family: monospace;
            font-size: 13px;
            resize: vertical;
        }
        @media (max-width: 768px) {
            textarea {
                font-size: 16px;
                min-height: 150px;
            }
        }
        input[type="text"],
        input[type="number"],
        input[type="date"] {
            font-size: 13px;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 4px;
        }
        @media (max-width: 768px) {
            input[type="text"],
            input[type="number"],
            input[type="date"] {
                font-size: 16px;
                min-height: 44px;
            }
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
            margin-top: 8px;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }
        @media (max-width: 768px) {
            button {
                padding: 12px 20px;
                font-size: 16px;
                min-height: 44px;
            }
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        button:active {
            transform: translateY(0);
        }
        button.secondary {
            background: linear-gradient(135deg, #78909c 0%, #546e7a 100%);
        }
        .mode-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        .mode-btn {
            flex: 1;
            margin: 0;
        }
        .mode-btn.active {
            background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
        }
        #mapCanvas {
            width: 100%;
            height: 600px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: crosshair;
            background: #f5f5f5;
            touch-action: none;
        }
        @media (max-width: 768px) {
            #mapCanvas {
                height: 400px;
            }
        }
        @media (min-width: 769px) and (max-aspect-ratio: 1/1) {
            #mapCanvas {
                height: 500px;
            }
        }
        .map-controls {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            flex-wrap: wrap;
        }
        .map-controls button {
            flex: 1;
            min-width: 120px;
            margin: 0;
        }
        @media (max-width: 768px) {
            .map-controls {
                gap: 6px;
            }
            .map-controls button {
                min-width: 100px;
                font-size: 13px;
                padding: 10px 12px;
            }
        }
        .obstacle-btn {
            margin: 4px 0;
        }
        .obstacle-btn.selected {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 12px;
        }
        .stat-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }
        .coordinate-item, .obstacle-item {
            background: white;
            padding: 10px;
            margin: 6px 0;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }
        @media (max-width: 768px) {
            .coordinate-item, .obstacle-item {
                padding: 12px;
                font-size: 14px;
                min-height: 50px;
            }
        }
        .coordinate-item input[type="checkbox"],
        .obstacle-item input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        @media (max-width: 768px) {
            .coordinate-item input[type="checkbox"],
            .obstacle-item input[type="checkbox"] {
                width: 24px;
                height: 24px;
                margin-right: 12px;
            }
        }
        .item-actions {
            display: flex;
            gap: 6px;
        }
        .item-actions button {
            width: auto;
            padding: 6px 12px;
            margin: 0;
            font-size: 12px;
            min-width: auto;
        }
        @media (max-width: 768px) {
            .item-actions button {
                padding: 8px 14px;
                font-size: 14px;
            }
        }
        .grid-display {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        .grid-display label {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .grid-display input[type="radio"] {
            margin-right: 6px;
        }
        .grid-display label:has(input:checked) {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        .toggle-switch input[type="checkbox"] {
            width: 50px;
            height: 26px;
            appearance: none;
            background: #ccc;
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        .toggle-switch input[type="checkbox"]:checked {
            background: #4caf50;
        }
        .toggle-switch input[type="checkbox"]::before {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }
        .toggle-switch input[type="checkbox"]:checked::before {
            left: 26px;
        }
        .custom-obstacle-form {
            background: #fff;
            padding: 15px;
            border-radius: 6px;
            margin-top: 10px;
        }
        .custom-obstacle-form input,
        .custom-obstacle-form select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 2px solid #e0e0e0;
            border-radius: 4px;
        }
        .color-picker {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .color-option {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
        }
        .color-option.selected {
            border-color: #333;
            transform: scale(1.1);
        }
        .custom-obstacle-display {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 4px;
            margin: 4px 0;
        }
        .custom-obstacle-display .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid #999;
        }
        .parse-result-item {
            background: white;
            padding: 10px;
            margin: 6px 0;
            border-radius: 6px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .parse-result-item input {
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .parse-result-item .name-input {
            flex: 2;
        }
        .parse-result-item .coord-input {
            flex: 1;
            width: 60px;
        }
        .filter-controls {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .filter-controls input,
        .filter-controls select {
            flex: 1;
            min-width: 120px;
        }
        .temp-message {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-weight: bold;
            text-align: center;
            color: #856404;
        }
        .coordinate-name-link {
            cursor: pointer;
            color: #667eea;
            text-decoration: none;
        }
        .coordinate-name-link:hover {
            text-decoration: underline;
        }
        .adjust-mode-panel {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 12px;
        }
        .adjust-mode-panel input {
            width: 100%;
            padding: 8px;
            margin: 8px 0;
            border: 2px solid #2196f3;
            border-radius: 4px;
        }
        /* ã‚°ãƒ«ãƒ¼ãƒ—ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³ã‚¹ã‚¿ã‚¤ãƒ« */
        .group-item {
            cursor: pointer;
            transition: background-color 0.2s;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 10px;
            background: white;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: flex-start;
        }
        .group-item:hover {
            border-color: #667eea;
        }
        .group-item.expanded {
            background-color: #f9fbff;
            border-color: #667eea;
        }
        .group-header {
            display: flex;
            flex-direction: column;
            width: 100%;
            padding: 12px;
            background: #e3f2fd;
            border-radius: 6px;
            margin-bottom: 0;
        }
        .group-expand-icon {
            margin-right: 8px;
            font-size: 16px;
            transition: transform 0.2s;
        }
        .group-item.expanded .group-expand-icon {
            transform: rotate(90deg);
        }
        .group-coordinates {
            display: none;
            margin-top: 12px;
            padding: 10px 12px;
            background: #f0f7ff;
            border-left: 4px solid #667eea;
            border-radius: 4px;
        }
        .group-item.expanded .group-coordinates {
            display: block;
        }
        .group-coord-item {
            background: white;
            padding: 8px 12px;
            margin: 6px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            color: #667eea;
            text-decoration: none;
            border: 1px solid #e3f2fd;
        }
        .group-coord-item:hover {
            background-color: #e3f2fd;
            border-color: #667eea;
        }
        .no-results-message {
            text-align: center;
            padding: 20px;
            color: #999;
            font-style: italic;
        }
        
        /* ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒœã‚¿ãƒ³ - ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ */
        .mode-dropdown {
            position: relative;
            display: inline-block;
        }
        
        .mode-dropdown-btn {
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            user-select: none;
        }
        
        .mode-dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 8px;
            background: white;
            min-width: 160px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            border-radius: 8px;
            z-index: 101;
            overflow: hidden;
        }
        
        .mode-dropdown-content.show {
            display: block;
        }
        
        .mode-dropdown-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .mode-dropdown-item:last-child {
            border-bottom: none;
        }
        
        .mode-dropdown-item:hover {
            background-color: #f5f5f5;
        }
        
        .mode-dropdown-item.active {
            background-color: #e3f2fd;
            font-weight: bold;
        }
        
        /* ã‚ºãƒ¼ãƒ ãƒœã‚¿ãƒ³ç¸¦ä¸¦ã³ */
        .zoom-controls {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .zoom-controls button {
            width: 50px;
            height: 50px;
            padding: 0;
            margin: 0;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            font-size: 20px;
        }
        
        .zoom-controls button:hover {
            transform: scale(1.1);
        }
        
        /* ãƒ•ã‚£ãƒ«ã‚¿è¡¨ç¤ºã‚¨ãƒªã‚¢ */
        .active-filters-display {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
            animation: slideDown 0.3s ease-out;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .active-filters-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: bold;
            color: #856404;
        }
        
        .filter-count {
            font-size: 13px;
            color: #856404;
        }
        
        .filter-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }
        
        .filter-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: white;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 13px;
            border: 1px solid #ffc107;
        }
        
        .filter-tag button {
            background: none;
            border: none;
            color: #dc3545;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            width: auto;
            margin: 0;
            min-height: auto;
            line-height: 1;
        }
        
        .filter-tag button:hover {
            transform: scale(1.2);
            box-shadow: none;
        }
        
        .clear-all-filters-btn {
            background: #dc3545 !important;
            color: white;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 13px;
            margin: 0;
            width: auto;
            min-height: auto;
        }
        
        @media (max-width: 768px) {
            .filter-tag {
                font-size: 12px;
                padding: 5px 10px;
            }
            
            .zoom-controls {
                right: 10px;
            }
            
            .zoom-controls button {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
        }

        /* ã‚°ãƒ«ãƒ¼ãƒ—ç®¡ç†ã¨ä¿å­˜æ¸ˆã¿åº§æ¨™ã®æ¨ªä¸¦ã³ */
        .bottom-split {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .bottom-split {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ—ºï¸ ã‚²ãƒ¼ãƒ åº§æ¨™ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ </h1>
            <p>ä¸€ç´šåœ°å¸¯ X200-439 Y760-999 ã®åº§æ¨™ç®¡ç†</p>
        </div>
        
        <div class="main-content">
            <!-- å·¦ã‚«ãƒ©ãƒ  -->
            <div class="left-column">
                <!-- éšœå®³ç‰©ç®¡ç† -->
                <div class="section obstacle-section">
                    <h2>ğŸš§ éšœå®³ç‰©ç®¡ç†</h2>
                    <div style="margin-bottom: 12px;">
                        <button onclick="selectObstacleType('rock')" class="obstacle-btn" id="obstacleRock">ğŸª¨ å²©</button>
                        <div id="customObstacleButtons"></div>
                        <button onclick="showCustomObstacleForm()" style="background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%); margin-top: 8px;">â• ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ã‚’ä½œæˆ</button>
                    </div>

                    <div id="customObstacleFormContainer" style="display: none;">
                        <div class="custom-obstacle-form">
                            <h3>ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ä½œæˆ</h3>
                            <input type="text" id="customObstacleName" placeholder="éšœå®³ç‰©å(ä¾‹:é™£å±‹)">
                            <div>
                                <label>é…ç½®æ–¹æ³•:</label>
                                <select id="customObstaclePlacementType">
                                    <option value="tap">ã‚¿ãƒƒãƒ—é…ç½®</option>
                                    <option value="single">å˜ä¸€ã‚»ãƒ«</option>
                                </select>
                            </div>
                            <div>
                                <label>è‰²ã‚’é¸æŠ:</label>
                                <div class="color-picker" id="colorPicker"></div>
                                <label style="margin-top: 10px;">ã¾ãŸã¯ä»»æ„ã®è‰²ã‚’æŒ‡å®š:</label>
                                <input type="color" id="customColorPicker" value="#FF6B6B" style="width: 100%; height: 40px; cursor: pointer;">
                            </div>
                            <button onclick="createCustomObstacle()" id="createObstacleBtn">ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆ</button>
                            <button onclick="cancelCustomObstacleForm()" class="secondary">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                            <div id="tempShapeMessage" style="display: none;" class="temp-message">
                                å½¢çŠ¶ã‚’å…¥åŠ›ã—çµ‚ã‚ã£ãŸã‚‰ã€å†åº¦ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„
                            </div>
                        </div>
                    </div>

                    <div id="obstacleList" style="max-height: 200px; overflow-y: auto; margin-top: 12px;"></div>
                    <button onclick="deleteSelectedObstacles()" style="background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%); margin-top: 8px;">ğŸ—‘ï¸ é¸æŠå‰Šé™¤</button>
                </div>

                <!-- çµ±è¨ˆ -->
                <div class="section stats-section">
                    <h2>ğŸ“Š çµ±è¨ˆæƒ…å ±</h2>
                    <div class="stats">
                        <div class="stat-item">
                            <div class="stat-value" id="coordCount">0</div>
                            <div class="stat-label">åº§æ¨™æ•°</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="obstacleCount">0</div>
                            <div class="stat-label">éšœå®³ç‰©</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="groupCount">0</div>
                            <div class="stat-label">ã‚°ãƒ«ãƒ¼ãƒ—</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="selectedCount">0</div>
                            <div class="stat-label">é¸æŠä¸­</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="occupancyRate">0%</div>
                            <div class="stat-label">å±…ä½ç¯„å›²å æœ‰ç‡</div>
                        </div>
                    </div>
                </div>

                <!-- æ“ä½œã‚¬ã‚¤ãƒ‰ -->
                <div class="section guide-section">
                    <h2>ğŸ“– æ“ä½œã‚¬ã‚¤ãƒ‰</h2>

                    <!-- åŸºæœ¬æ“ä½œ -->
                    <details class="guide-item">
                        <summary>ğŸ–±ï¸ ãƒãƒƒãƒ—æ“ä½œ</summary>
                        <div class="guide-content">
                            <p><strong>ğŸ” æ‹¡å¤§ç¸®å°:</strong> ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«</p>
                            <p><strong>âœ‹ ãƒ‘ãƒ³ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰:</strong></p>
                            <ul>
                                <li>é–²è¦§ãƒ¢ãƒ¼ãƒ‰: ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°</li>
                                <li>å…¥åŠ›ãƒ»å‰Šé™¤ãƒ»èª¿æ•´ãƒ¢ãƒ¼ãƒ‰: ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼+ãƒ‰ãƒ©ãƒƒã‚°</li>
                                <li>ã‚¹ãƒãƒ›: äºŒæœ¬æŒ‡ã§ã‚¹ãƒ©ã‚¤ãƒ‰</li>
                            </ul>
                            <p><strong>ğŸ  ä¸€ç´šåœ°å¸¯ã¸ã‚¸ãƒ£ãƒ³ãƒ—:</strong> ãƒãƒƒãƒ—å³å´ã®ğŸ ãƒœã‚¿ãƒ³</p>
                            <p><strong>ğŸ–¼ï¸ å…¨ç”»é¢è¡¨ç¤º:</strong> ãƒãƒƒãƒ—ä¸‹éƒ¨ã®å…¨ç”»é¢è¡¨ç¤ºãƒœã‚¿ãƒ³</p>
                        </div>
                    </details>

                    <!-- åº§æ¨™å…¥åŠ› -->
                    <details class="guide-item">
                        <summary>ğŸ“ åº§æ¨™å…¥åŠ›</summary>
                        <div class="guide-content">
                            <p><strong>å…¥åŠ›å½¢å¼:</strong></p>
                            <ul>
                                <li>åŸºæœ¬: <code>åå‰ @Xåº§æ¨™ Yåº§æ¨™</code></li>
                                <li>ä¾‹: <code>åŸA @320 850</code></li>
                                <li>é€£ç¶šå…¥åŠ›: æ”¹è¡Œã€ã‚«ãƒ³ãƒã€ã¾ãŸã¯ä»»æ„ã®åŒºåˆ‡ã‚Šæ–‡å­—ã§åŒºåˆ‡ã‚‹</li>
                            </ul>
                            <p><strong>ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆ:</strong> ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›ã™ã‚‹ã¨è‡ªå‹•çš„ã«ã‚°ãƒ«ãƒ¼ãƒ—ãŒä½œæˆã•ã‚Œã¾ã™</p>
                            <p><strong>æ‰‹é †:</strong></p>
                            <ol>
                                <li>åº§æ¨™å…¥åŠ›æ¬„ã«ãƒ‡ãƒ¼ã‚¿ã‚’å…¥åŠ›</li>
                                <li>ã€ŒğŸ“¥ åº§æ¨™ã‚’è§£æã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯</li>
                                <li>è§£æçµæœã‚’ç¢ºèªãƒ»ä¿®æ­£</li>
                                <li>ã€ŒğŸ’¾ åº§æ¨™ã‚’ä¿å­˜ã€ãƒœã‚¿ãƒ³ã§ä¿å­˜</li>
                            </ol>
                        </div>
                    </details>

                    <!-- éšœå®³ç‰©å…¥åŠ› -->
                    <details class="guide-item">
                        <summary>ğŸš§ éšœå®³ç‰©å…¥åŠ›</summary>
                        <div class="guide-content">
                            <p><strong>äº‹å‰æº–å‚™:</strong></p>
                            <ol>
                                <li>éšœå®³ç‰©ç®¡ç†ãƒ‘ãƒãƒ«ã§éšœå®³ç‰©ã‚’é¸æŠ</li>
                                <li>ãƒãƒƒãƒ—ä¸Šéƒ¨ã§ã€Œâœï¸ å…¥åŠ›ã€ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠ</li>
                            </ol>
                            <p><strong>å…¥åŠ›æ–¹æ³•:</strong></p>
                            <ul>
                                <li><strong>å˜ä¸€ã‚»ãƒ«:</strong> ãƒãƒƒãƒ—ä¸Šã‚’ã‚¯ãƒªãƒƒã‚¯</li>
                                <li><strong>è¤‡æ•°ã‚»ãƒ«:</strong> ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ç¯„å›²é¸æŠ</li>
                                <li><strong>ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«:</strong> ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼+ãƒ‰ãƒ©ãƒƒã‚°</li>
                            </ul>
                            <p><strong>ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©:</strong> ã€Œâ• ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ã‚’ä½œæˆã€ã‹ã‚‰è‰²ã‚„åå‰ã‚’è‡ªç”±ã«è¨­å®šå¯èƒ½</p>
                            <p><strong>å‰Šé™¤:</strong> ã€ŒğŸ—‘ï¸ å‰Šé™¤ã€ãƒ¢ãƒ¼ãƒ‰ã§éšœå®³ç‰©ã‚’ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°</p>
                        </div>
                    </details>

                    <!-- ã‚°ãƒ«ãƒ¼ãƒ—ç®¡ç† -->
                    <details class="guide-item">
                        <summary>ğŸ“¦ ã‚°ãƒ«ãƒ¼ãƒ—ç®¡ç†</summary>
                        <div class="guide-content">
                            <p><strong>ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆ:</strong></p>
                            <ul>
                                <li>ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›ã—ã¦ã€Œâ• ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆã€</li>
                                <li>ã¾ãŸã¯åº§æ¨™å…¥åŠ›æ™‚ã«ã‚°ãƒ«ãƒ¼ãƒ—åã‚’æŒ‡å®š</li>
                            </ul>
                            <p><strong>åº§æ¨™ã®è¿½åŠ :</strong></p>
                            <ol>
                                <li>ä¿å­˜æ¸ˆã¿åº§æ¨™ãƒªã‚¹ãƒˆã§åº§æ¨™ã‚’é¸æŠ</li>
                                <li>ã‚°ãƒ«ãƒ¼ãƒ—ã®ã€Œâ•è¿½åŠ ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯</li>
                            </ol>
                            <p><strong>ã‚°ãƒ«ãƒ¼ãƒ—å†…ã®åº§æ¨™ã‚’è¡¨ç¤º:</strong> ã‚°ãƒ«ãƒ¼ãƒ—åã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦å±•é–‹</p>
                            <p><strong>ã‚°ãƒ«ãƒ¼ãƒ—å†…ã®åº§æ¨™ã‚’é¸æŠ:</strong> ã€Œé¸æŠã€ãƒœã‚¿ãƒ³ã§ä¸€æ‹¬é¸æŠ</p>
                        </div>
                    </details>

                    <!-- åº§æ¨™èª¿æ•´ -->
                    <details class="guide-item">
                        <summary>ğŸ”§ åº§æ¨™èª¿æ•´</summary>
                        <div class="guide-content">
                            <p><strong>æ‰‹é †:</strong></p>
                            <ol>
                                <li>ãƒãƒƒãƒ—ä¸Šéƒ¨ã§ã€ŒğŸ”§ åº§æ¨™èª¿æ•´ã€ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠ</li>
                                <li>èª¿æ•´ã—ãŸã„åº§æ¨™ã‚’ãƒ‰ãƒ©ãƒƒã‚°</li>
                                <li>ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›</li>
                                <li>ã€ŒğŸ’¾ èª¿æ•´åº§æ¨™ã‚’ä¿å­˜ã€ã§æ–°ã—ã„ã‚°ãƒ«ãƒ¼ãƒ—ã¨ã—ã¦ä¿å­˜</li>
                            </ol>
                            <p><strong>æ³¨æ„:</strong> å…ƒã®åº§æ¨™ã¯å¤‰æ›´ã•ã‚Œãšã€èª¿æ•´å¾Œã®åº§æ¨™ãŒæ–°è¦ã‚°ãƒ«ãƒ¼ãƒ—ã¨ã—ã¦ä¿å­˜ã•ã‚Œã¾ã™</p>
                        </div>
                    </details>
                </div>
            </div>

            <!-- å³ã‚«ãƒ©ãƒ  -->
            <div class="right-column">
                <!-- ãƒãƒƒãƒ—è¡¨ç¤º -->
                <div class="section map-section floating-controls">
                    <h2>ğŸ—ºï¸ ãƒãƒƒãƒ—è¡¨ç¤º</h2>

                    <!-- ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºåˆ‡æ›¿ -->
                    <div class="grid-display">
                        <label>
                            <input type="radio" name="gridType" value="square" checked onchange="changeGridType('square')">
                            â¬œ æ­£æ–¹å½¢
                        </label>
                        <label>
                            <input type="radio" name="gridType" value="diamond" onchange="changeGridType('diamond')">
                            ğŸ”· ã²ã—å½¢
                        </label>
                    </div>

                    <!-- ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ï¼ˆãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ï¼‰ -->
                    <div class="mode-toggle">
                        <div class="mode-dropdown">
                            <div class="mode-dropdown-btn" onclick="toggleModeDropdown()">
                                <span id="currentModeText">ğŸ‘€ é–²è¦§</span>
                                <span>â–¼</span>
                            </div>
                            <div class="mode-dropdown-content" id="modeDropdownContent">
                                <div class="mode-dropdown-item active" onclick="selectMode('view', 'ğŸ‘€ é–²è¦§')">ğŸ‘€ é–²è¦§</div>
                                <div class="mode-dropdown-item" onclick="selectMode('input', 'âœï¸ å…¥åŠ›')">âœï¸ å…¥åŠ›</div>
                                <div class="mode-dropdown-item" onclick="selectMode('adjust', 'ğŸ”§ åº§æ¨™èª¿æ•´')">ğŸ”§ åº§æ¨™èª¿æ•´</div>
                                <div class="mode-dropdown-item" onclick="selectMode('delete', 'ğŸ—‘ï¸ å‰Šé™¤')">ğŸ—‘ï¸ å‰Šé™¤</div>
                            </div>
                        </div>
                    </div>

                    <!-- åº§æ¨™èª¿æ•´ãƒ¢ãƒ¼ãƒ‰ãƒ‘ãƒãƒ« -->
                    <div id="adjustModePanel" class="adjust-mode-panel" style="display: none;">
                        <strong>åº§æ¨™èª¿æ•´ãƒ¢ãƒ¼ãƒ‰</strong>
                        <input type="text" id="adjustGroupName" placeholder="ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›">
                        <button onclick="saveAdjustedGroup()">ğŸ’¾ èª¿æ•´åº§æ¨™ã‚’ä¿å­˜</button>
                        <button onclick="cancelAdjustMode()" class="secondary">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                    </div>

                    <canvas id="mapCanvas"></canvas>

                    <!-- ã‚ºãƒ¼ãƒ ãƒœã‚¿ãƒ³ï¼ˆç¸¦ä¸¦ã³ãƒ»å³å´ä¸­å¤®ï¼‰ -->
                    <div class="zoom-controls">
                        <button onclick="zoomIn()" title="æ‹¡å¤§">ğŸ”</button>
                        <button onclick="zoomOut()" title="ç¸®å°">ğŸ”</button>
                        <button onclick="jumpToPrimeZone()" title="ä¸€ç´šåœ°å¸¯ã¸" style="background: linear-gradient(135deg, #ffd700 0%, #ffb700 100%);">ğŸ </button>
                    </div>

                    <!-- ä¸‹éƒ¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
                    <div class="map-controls">
                        <button onclick="toggleFullscreen()" id="fullscreenBtn">ğŸ–¼ï¸ å…¨ç”»é¢è¡¨ç¤º</button>
                    </div>
                </div>

                <!-- åº§æ¨™å…¥åŠ› -->
                <div class="section coord-input-section">
                    <h2>ğŸ“ åº§æ¨™å…¥åŠ›</h2>
                    <label>ã‚°ãƒ«ãƒ¼ãƒ—å(ä»»æ„ãƒ»ç©ºæ¬„å¯):</label>
                    <input type="text" id="coordInputGroupName" placeholder="ã‚°ãƒ«ãƒ¼ãƒ—åã‚’æŒ‡å®šã™ã‚‹ã¨è‡ªå‹•ä½œæˆã•ã‚Œã¾ã™" style="width: 100%; margin-bottom: 8px; padding: 8px;">
                    <label>åŒºåˆ‡ã‚Šæ–‡å­—(ä»»æ„ãƒ»ç©ºæ¬„å¯):</label>
                    <input type="text" id="customDelimiter" placeholder="ä¾‹: | ã¾ãŸã¯ : ãªã©" style="width: 100%; margin-bottom: 8px;">
                    <textarea id="coordInput" placeholder="åº§æ¨™ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„&#10;ä¾‹:&#10;åŸA @320 850&#10;åŸB @350 870&#10;&#10;ã¾ãŸã¯é€£ç¶šå…¥åŠ›:&#10;äº¬ç”°æ¥“èŠ±: @385 767ã€ç¶¾ç€¬: è©²å½“ãªã—ç¶¾ç€¬ã¯ã‚‹ã‹1@354 875"></textarea>
                    <button onclick="parseCoordinates()">ğŸ“¥ åº§æ¨™ã‚’è§£æ</button>
                </div>

                <!-- è§£æçµæœ -->
                <div class="section" id="parseResultSection" style="display: none;">
                    <h2>âœ… è§£æçµæœ(ä¿®æ­£å¯èƒ½)</h2>
                    <div id="parseResult" style="max-height: 300px; overflow-y: auto;"></div>
                    <button onclick="saveCoordinates()">ğŸ’¾ åº§æ¨™ã‚’ä¿å­˜</button>
                    <button onclick="clearParseResult()" class="secondary">ğŸ—‘ï¸ è§£æçµæœã‚’ã‚¯ãƒªã‚¢</button>
                </div>

                <!-- ä¸‹éƒ¨ã®2ã‚«ãƒ©ãƒ ä¸¦åˆ—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
                <div class="bottom-row">
                    <!-- ã‚°ãƒ«ãƒ¼ãƒ—ç®¡ç† -->
                    <div class="section group-section">
                        <h2>ğŸ“¦ ã‚°ãƒ«ãƒ¼ãƒ—ç®¡ç†</h2>
                        <input type="text" id="groupName" placeholder="ã‚°ãƒ«ãƒ¼ãƒ—å" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <button onclick="createGroup()">â• ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆ</button>
                        <div id="groupList" style="max-height: 400px; overflow-y: auto; margin-top: 12px;"></div>
                    </div>

                    <!-- åº§æ¨™ç®¡ç† -->
                    <div class="section saved-coords-section">
                        <h2>ğŸ“‹ ä¿å­˜æ¸ˆã¿åº§æ¨™</h2>

                        <!-- ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ»ã‚½ãƒ¼ãƒˆ -->
                        <div class="filter-controls">
                            <input type="text" id="nameFilter" placeholder="åç§°æ¤œç´¢" onkeyup="applyFilters()" style="width: 100%;">
                        </div>
                        <div class="filter-controls" style="display: flex; gap: 10px; align-items: center;">
                            <input type="date" id="dateFilterFrom" onchange="applyFilters()" style="flex: 1;">
                            <span>ã‹ã‚‰</span>
                            <input type="date" id="dateFilterTo" onchange="applyFilters()" style="flex: 1;">
                        </div>
                        <div class="filter-controls" style="display: flex; gap: 5px; margin-top: 5px;">
                            <button onclick="setDateFilter('today')" class="secondary" style="flex: 1; padding: 6px;">ä»Šæ—¥</button>
                            <button onclick="setDateFilter('week')" class="secondary" style="flex: 1; padding: 6px;">ä»Šé€±</button>
                            <button onclick="setDateFilter('month')" class="secondary" style="flex: 1; padding: 6px;">ä»Šæœˆ</button>
                            <button onclick="setDateFilter('year')" class="secondary" style="flex: 1; padding: 6px;">ä»Šå¹´</button>
                        </div>
                        <div class="filter-controls">
                            <select id="sortBy" onchange="applyFilters()">
                                <option value="date-desc">ç™»éŒ²æ—¥æ™‚(æ–°â†’å¤)</option>
                                <option value="date-asc">ç™»éŒ²æ—¥æ™‚(å¤â†’æ–°)</option>
                                <option value="name-asc">åå‰(Aâ†’Z)</option>
                                <option value="name-desc">åå‰(Zâ†’A)</option>
                                <option value="x-asc">Xåº§æ¨™(å°â†’å¤§)</option>
                                <option value="x-desc">Xåº§æ¨™(å¤§â†’å°)</option>
                                <option value="y-asc">Yåº§æ¨™(å°â†’å¤§)</option>
                                <option value="y-desc">Yåº§æ¨™(å¤§â†’å°)</option>
                            </select>
                            <button onclick="clearFilters()" class="secondary" style="width: auto; padding: 8px 16px; margin: 0;">ãƒ•ã‚£ãƒ«ã‚¿è§£é™¤</button>
                        </div>

                        <div class="toggle-switch">
                            <span>ä¸€æ‹¬é¸æŠãƒ¢ãƒ¼ãƒ‰</span>
                            <input type="checkbox" id="rangeSelectMode" onchange="toggleRangeSelectMode()">
                            <span style="font-size: 12px; color: #666; margin-left: 8px;">ï¼ˆONæ™‚: ç¯„å›²é¸æŠãŒå¯èƒ½ï¼‰</span>
                        </div>

                        <!-- ãƒ•ã‚£ãƒ«ã‚¿è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
                        <div id="activeFiltersDisplay" class="active-filters-display" style="display: none;"></div>

                        <div id="coordinateList" style="max-height: 300px; overflow-y: auto;"></div>
                        <div class="map-controls" style="margin-top: 12px;">
                            <button onclick="showSelectedCoordinatesOnly()" class="secondary">ğŸ‘ï¸ é¸æŠæ¸ˆã¿åº§æ¨™ã®ã¿è¡¨ç¤º</button>
                            <button onclick="showAllCoordinates()" class="secondary">ğŸ‘ï¸ ã™ã¹ã¦è¡¨ç¤º</button>
                            <button onclick="deleteSelectedCoordinates()" style="background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);">ğŸ—‘ï¸ é¸æŠå‰Šé™¤</button>
                            <button onclick="exportData()" style="background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);">ğŸ’¾ ãƒ‡ãƒ¼ã‚¿å‡ºåŠ›</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // Firebase åˆæœŸåŒ–
        // ========================================
        const firebaseConfig = {
            apiKey: "AIzaSyAoN96jdkx9kVm0mfj50n-5WzZOkLzGJVI",
            authDomain: "shishi-zahyo.firebaseapp.com",
            databaseURL: "https://shishi-zahyo-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "shishi-zahyo",
            storageBucket: "shishi-zahyo.firebasestorage.app",
            messagingSenderId: "380340912647",
            appId: "1:380340912647:web:d20e62f51ed9dc590560a2",
            measurementId: "G-NQ0482B0YC"
        };

        // FirebaseåˆæœŸåŒ–
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // Firebaseãƒ‡ãƒ¼ã‚¿å‚ç…§
        const coordinatesRef = database.ref('coordinates');
        const groupsRef = database.ref('groups');
        const obstaclesRef = database.ref('obstacles');

        // ========================================
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        // ========================================
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        
        // ã‚²ãƒ¼ãƒ å…¨ä½“ã®åº§æ¨™ç¯„å›²
        const worldBounds = {
            minX: 0,
            maxX: 700,
            minY: 0,
            maxY: 1900
        };
        
        // ä¸€ç´šåœ°å¸¯ã®ç¯„å›²
        const primeZone = {
            minX: 200,
            maxX: 439,
            minY: 760,
            maxY: 999
        };
        
        // åŸã®å›ºå®šãƒ‡ãƒ¼ã‚¿
        const castles = [
            { name: 'äºŒæ¡åŸ', x: 320, y: 880 },
            { name: 'é›‘è³€åŸ', x: 416, y: 785 },
            { name: 'å¾Œç€¬å±±åŸ', x: 220, y: 860 },
            { name: 'ä¼Šè³€ä¸Šé‡åŸ', x: 388, y: 949 }
        ];
        
        // æç”»è¨­å®š
        let scale = 5;
        let offsetX = (primeZone.minX + primeZone.maxX) / 2;
        let offsetY = (primeZone.minY + primeZone.maxY) / 2;
        let gridType = 'square';
        
        // ãƒ‡ãƒ¼ã‚¿
        let parsedCoordinates = [];
        let savedCoordinates = [];
        let selectedCoordinateIds = new Set();
        let hiddenCoordinateIds = new Set();
        let duplicateCoordinateIds = new Set();
        let coordinateGroups = [];
        let filteredCoordinates = [];
        let obstacles = [];
        let selectedObstacleIds = new Set();
        let customObstacles = [];
        
        // UIçŠ¶æ…‹
        let currentMode = 'view';
        let selectedObstacleType = null;
        let tempSelection = new Set();
        let isCreatingCustomObstacle = false;
        let customObstacleInProgress = null;
        let rangeSelectMode = false;
        let isFilterActive = false;
        let rangeSelectStart = null;
        let expandedGroupId = null;
        let groupFilterActive = false;
        
        // ãƒ‰ãƒ©ãƒƒã‚°é¸æŠç”¨
        let isDragging = false;
        let dragStartCell = null;
        let dragCurrentCell = null;
        
        // åº§æ¨™èª¿æ•´ãƒ¢ãƒ¼ãƒ‰ç”¨
        let adjustMode = {
            active: false,
            groupName: '',
            coordinates: []
        };
        let draggedCoordinate = null;
        
        // éšœå®³ç‰©ã®åå‰
        const obstacleNames = {
            'rock': 'ğŸª¨ å²©'
        };
        
        // ã‚¿ãƒƒãƒæ“ä½œç”¨
        let touches = [];
        let lastTouchDistance = 0;
        let isPanning = false;
        let lastPanPos = null;
        let isSpaceKeyPressed = false; // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼æŠ¼ä¸‹çŠ¶æ…‹

        // ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ç”¨ã®è‰²ãƒ‘ãƒ¬ãƒƒãƒˆ
        const colorPalette = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
            '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B88B', '#AAB7B8',
            '#FF8ED4', '#00D2FF', '#3F51B5', '#E91E63', '#009688'
        ];

        // ========================================
        // Firebase ãƒ‡ãƒ¼ã‚¿ç®¡ç†é–¢æ•°
        // ========================================

        // Firebaseã‹ã‚‰ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ï¼ˆåˆå›ãƒ­ãƒ¼ãƒ‰ï¼‰
        function loadFromFirebase() {
            console.log('Firebaseã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...');

            // åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã¨ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸ
            coordinatesRef.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    savedCoordinates = Object.keys(data).map(key => ({
                        ...data[key],
                        id: data[key].id || key
                    }));
                    console.log(`${savedCoordinates.length}ä»¶ã®åº§æ¨™ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
                    updateCoordinatesList();

                    // ç¢ºå®Ÿã«å†æç”»ã•ã‚Œã‚‹ã‚ˆã†requestAnimationFrameã‚’ä½¿ç”¨
                    requestAnimationFrame(() => {
                        drawMap();
                    });

                    updateStats();
                } else {
                    console.log('åº§æ¨™ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
                }
            });

            // ã‚°ãƒ«ãƒ¼ãƒ—ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã¨ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸ
            groupsRef.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    coordinateGroups = Object.keys(data).map(key => ({
                        ...data[key],
                        id: data[key].id || key
                    }));
                    console.log(`${coordinateGroups.length}ä»¶ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
                    updateGroupsList();
                } else {
                    console.log('ã‚°ãƒ«ãƒ¼ãƒ—ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
                    // åˆå›ã®ã¿ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆ
                    if (coordinateGroups.length === 0) {
                        createDefaultGroup();
                    }
                }
            });

            // éšœå®³ç‰©ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã¨ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸ
            obstaclesRef.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const obstacleData = data.obstacles || [];
                    const customObstacleData = data.customObstacles || [];

                    obstacles = obstacleData;
                    customObstacles = customObstacleData;

                    console.log(`${obstacles.length}ä»¶ã®éšœå®³ç‰©ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
                    updateObstaclesList();
                    updateCustomObstaclesList();

                    // ç¢ºå®Ÿã«å†æç”»ã•ã‚Œã‚‹ã‚ˆã†requestAnimationFrameã‚’ä½¿ç”¨
                    requestAnimationFrame(() => {
                        drawMap();
                    });
                } else {
                    console.log('éšœå®³ç‰©ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
                }
            });
        }

        // åº§æ¨™ã‚’Firebaseã«ä¿å­˜
        function saveCoordinateToFirebase(coordinate) {
            const coordId = coordinate.id.toString();
            return coordinatesRef.child(coordId).set(coordinate);
        }

        // åº§æ¨™ã‚’Firebaseã‹ã‚‰å‰Šé™¤
        function deleteCoordinateFromFirebase(coordId) {
            return coordinatesRef.child(coordId.toString()).remove();
        }

        // ã‚°ãƒ«ãƒ¼ãƒ—ã‚’Firebaseã«ä¿å­˜
        function saveGroupToFirebase(group) {
            const groupId = group.id.toString();
            return groupsRef.child(groupId).set(group);
        }

        // ã‚°ãƒ«ãƒ¼ãƒ—ã‚’Firebaseã‹ã‚‰å‰Šé™¤
        function deleteGroupFromFirebase(groupId) {
            return groupsRef.child(groupId.toString()).remove();
        }

        // ã™ã¹ã¦ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’Firebaseã«ä¿å­˜
        function saveAllGroupsToFirebase() {
            const groupsData = {};
            coordinateGroups.forEach(group => {
                groupsData[group.id] = group;
            });
            return groupsRef.set(groupsData);
        }

        // éšœå®³ç‰©ã‚’Firebaseã«ä¿å­˜
        function saveObstaclesToFirebase() {
            return obstaclesRef.set({
                obstacles: obstacles,
                customObstacles: customObstacles
            });
        }

        // ========================================
        // åˆæœŸåŒ–
        // ========================================
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

            // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ã®ãƒ‘ãƒ³æ“ä½œ
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            initColorPicker();

            // ä¿®æ­£3: ãƒ­ãƒ¼ã‚«ãƒ«ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã§æ—¥ä»˜ã‚’è¨­å®š
            const today = new Date();
            const dateString = getLocalDateString(today);
            document.getElementById('dateFilterTo').value = dateString;

            // Firebaseã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚°ãƒ«ãƒ¼ãƒ—ã¯èª­ã¿è¾¼ã¿æ™‚ã«å¿…è¦ã«å¿œã˜ã¦ä½œæˆï¼‰
            loadFromFirebase();

            drawMap();
            updateStats();
        }
        
        // ä¿®æ­£3: ãƒ­ãƒ¼ã‚«ãƒ«ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã§æ—¥ä»˜æ–‡å­—åˆ—ã‚’å–å¾—
        function getLocalDateString(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚°ãƒ«ãƒ¼ãƒ—ã®ä½œæˆ
        function createDefaultGroup() {
            const defaultGroup = {
                id: 'default',
                name: 'ç™»éŒ²æ¸ˆã¿åº§æ¨™',
                coordinateIds: [],
                createdAt: new Date().toISOString()
            };
            coordinateGroups.push(defaultGroup);

            // Firebaseã«ä¿å­˜
            saveGroupToFirebase(defaultGroup).catch(error => {
                console.error('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚°ãƒ«ãƒ¼ãƒ—ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
            });

            updateGroupsList();
        }
        
        // æ—¥ä»˜ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ (ä¿®æ­£3å¯¾å¿œ)
        function setDateFilter(period) {
            const today = new Date();
            const dateFilterFrom = document.getElementById('dateFilterFrom');
            const dateFilterTo = document.getElementById('dateFilterTo');
            
            // çµ‚äº†æ—¥ã¯å¸¸ã«ä»Šæ—¥
            dateFilterTo.value = getLocalDateString(today);
            
            let startDate = new Date();
            switch(period) {
                case 'today':
                    startDate = new Date(today);
                    break;
                case 'week':
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - today.getDay());
                    break;
                case 'month':
                    startDate = new Date(today.getFullYear(), today.getMonth(), 1);
                    break;
                case 'year':
                    startDate = new Date(today.getFullYear(), 0, 1);
                    break;
            }
            
            dateFilterFrom.value = getLocalDateString(startDate);
            applyFilters();
        }
        
        // ç‰¹å®šã®æ—¥ä»˜ã§çµã‚Šè¾¼ã¿
        function filterByDate(dateISO) {
            const dateFilterFrom = document.getElementById('dateFilterFrom');
            const dateFilterTo = document.getElementById('dateFilterTo');
            
            dateFilterFrom.value = dateISO;
            dateFilterTo.value = dateISO;
            applyFilters();
        }
        
        // è‰²ãƒ”ãƒƒã‚«ãƒ¼ã®åˆæœŸåŒ–
        function initColorPicker() {
            const picker = document.getElementById('colorPicker');
            picker.innerHTML = '';
            colorPalette.forEach((color, index) => {
                const div = document.createElement('div');
                div.className = 'color-option' + (index === 0 ? ' selected' : '');
                div.style.backgroundColor = color;
                div.onclick = () => selectColor(div, color);
                picker.appendChild(div);
            });
        }
        
        function selectColor(element, color) {
            document.querySelectorAll('.color-option').forEach(el => el.classList.remove('selected'));
            element.classList.add('selected');
        }
        
        function getSelectedColor() {
            const selected = document.querySelector('.color-option.selected');
            if (selected) {
                return selected.style.backgroundColor;
            }
            const customPicker = document.getElementById('customColorPicker');
            if (customPicker) {
                return customPicker.value;
            }
            return colorPalette[0];
        }
        
        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ãƒªã‚µã‚¤ã‚º (ä¿®æ­£2å¯¾å¿œ)
        function resizeCanvas() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            
            const dpr = window.devicePixelRatio || 1;
            
            // ä¿®æ­£2: å…¨ç”»é¢è¡¨ç¤ºæ™‚ã¯ç”»é¢ã‚µã‚¤ã‚ºã‚’ä½¿ç”¨
            let displayWidth, displayHeight;
            if (document.fullscreenElement) {
                displayWidth = window.innerWidth;
                displayHeight = window.innerHeight;
            } else {
                displayWidth = rect.width - 40;
                displayHeight = Math.min(600, window.innerHeight * 0.5);
            }
            
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
            
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            ctx.scale(dpr, dpr);
            
            drawMap();
        }
        
        // åº§æ¨™å¤‰æ›(ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™â†’ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™)
        function worldToScreen(x, y) {
            const dpr = window.devicePixelRatio || 1;
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;
            
            if (gridType === 'diamond') {
                const dx = x - offsetX;
                const dy = y - offsetY;
                
                const screenX = width / 2 + (dx + dy) * scale / 2;
                const screenY = height / 2 + (dx - dy) * scale * 0.876 / 2;
                
                return { x: screenX, y: screenY };
            } else {
                return {
                    x: width / 2 + (y - offsetY) * scale,
                    y: height / 2 + (x - offsetX) * scale
                };
            }
        }
        
        // åº§æ¨™å¤‰æ›(ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™â†’ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™)
        function screenToWorld(screenX, screenY) {
            const dpr = window.devicePixelRatio || 1;
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;
            
            if (gridType === 'diamond') {
                const sx = (screenX - width / 2) / scale * 2;
                const sy = (screenY - height / 2) / scale / 0.876 * 2;
                
                const worldX = offsetX + (sx + sy) / 2;
                const worldY = offsetY + (sx - sy) / 2;
                
                return {
                    x: Math.round(worldX),
                    y: Math.round(worldY)
                };
            } else {
                return {
                    x: Math.round(offsetX + (screenY - height / 2) / scale),
                    y: Math.round(offsetY + (screenX - width / 2) / scale)
                };
            }
        }
        
        // ã‚°ãƒªãƒƒãƒ‰ã‚¿ã‚¤ãƒ—ã®å¤‰æ›´
        function changeGridType(type) {
            gridType = type;
            resizeCanvas();
        }
        
        // ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ãƒˆã‚°ãƒ«
        function toggleModeDropdown() {
            const dropdown = document.getElementById('modeDropdownContent');
            dropdown.classList.toggle('show');
        }
        
        // ãƒ¢ãƒ¼ãƒ‰é¸æŠ
        function selectMode(mode, text) {
            // ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã‚’é–‰ã˜ã‚‹
            document.getElementById('modeDropdownContent').classList.remove('show');
            
            // ç¾åœ¨ã®ãƒ¢ãƒ¼ãƒ‰ãƒ†ã‚­ã‚¹ãƒˆã‚’æ›´æ–°
            document.getElementById('currentModeText').textContent = text;
            
            // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
            document.querySelectorAll('.mode-dropdown-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // ãƒ¢ãƒ¼ãƒ‰ã‚’å¤‰æ›´
            changeModeInternal(mode);
        }
        
        // å†…éƒ¨çš„ã«ãƒ¢ãƒ¼ãƒ‰ã‚’å¤‰æ›´ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã‚ãªã„ï¼‰
        function changeModeInternal(mode) {
            if (mode === 'adjust' && !adjustMode.active) {
                startAdjustMode();
                return;
            }
            
            currentMode = mode;
            tempSelection.clear();
            draggedCoordinate = null;
            isDragging = false;
            dragStartCell = null;
            
            if (mode === 'input') {
                canvas.style.cursor = 'crosshair';
            } else if (mode === 'adjust') {
                canvas.style.cursor = 'move';
            } else if (mode === 'delete') {
                canvas.style.cursor = 'not-allowed';
            } else {
                canvas.style.cursor = 'default';
            }
            
            drawMap();
        }
        
        // ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³å¤–ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰é–‰ã˜ã‚‹
        window.onclick = function(event) {
            if (!event.target.matches('.mode-dropdown-btn') && !event.target.matches('.mode-dropdown-btn *')) {
                const dropdowns = document.getElementsByClassName('mode-dropdown-content');
                for (let i = 0; i < dropdowns.length; i++) {
                    if (dropdowns[i].classList.contains('show')) {
                        dropdowns[i].classList.remove('show');
                    }
                }
            }
        }
        
        // ãƒ¢ãƒ¼ãƒ‰å¤‰æ›´ï¼ˆå¾“æ¥ã®ãƒœã‚¿ãƒ³ç”¨ - äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
        function changeMode(mode) {
            if (mode === 'adjust' && !adjustMode.active) {
                startAdjustMode();
                return;
            }
            
            currentMode = mode;
            tempSelection.clear();
            draggedCoordinate = null;
            isDragging = false;
            dragStartCell = null;
            
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            if (mode === 'input') {
                canvas.style.cursor = 'crosshair';
            } else if (mode === 'adjust') {
                canvas.style.cursor = 'move';
            } else if (mode === 'delete') {
                canvas.style.cursor = 'not-allowed';
            } else {
                canvas.style.cursor = 'default';
            }
            
            drawMap();
        }
        
        // åº§æ¨™èª¿æ•´ãƒ¢ãƒ¼ãƒ‰é–‹å§‹
        function startAdjustMode() {
            if (savedCoordinates.length === 0) {
                alert('èª¿æ•´ã™ã‚‹åº§æ¨™ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            adjustMode.active = true;
            adjustMode.coordinates = savedCoordinates.map(c => ({...c}));
            
            const timestamp = new Date();
            const dateStr = timestamp.toISOString().replace(/[-:T]/g, '').split('.')[0];
            adjustMode.groupName = `åº§æ¨™èª¿æ•´_${dateStr}`;
            
            document.getElementById('adjustGroupName').value = adjustMode.groupName;
            document.getElementById('adjustModePanel').style.display = 'block';
            
            currentMode = 'adjust';
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector('.mode-btn:nth-child(3)').classList.add('active');
            canvas.style.cursor = 'move';
            
            drawMap();
        }
        
        // èª¿æ•´åº§æ¨™ã‚’ä¿å­˜
        function saveAdjustedGroup() {
            const groupName = document.getElementById('adjustGroupName').value.trim();
            if (!groupName) {
                alert('ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            const coordIds = [];
            adjustMode.coordinates.forEach((c, i) => {
                const newCoord = {
                    ...c,
                    id: Date.now().toString() + '-' + i + '-' + Math.floor(Math.random() * 1000000),
                    createdAt: new Date().toISOString()
                };
                savedCoordinates.push(newCoord);
                coordIds.push(newCoord.id);

                // Firebaseã«åº§æ¨™ã‚’ä¿å­˜
                saveCoordinateToFirebase(newCoord).catch(error => {
                    console.error('åº§æ¨™ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                });
            });

            coordinateGroups.push({
                id: Date.now().toString(),
                name: groupName,
                coordinateIds: coordIds,
                createdAt: new Date().toISOString()
            });

            // ã‚°ãƒ«ãƒ¼ãƒ—ã‚’Firebaseã«ä¿å­˜
            saveAllGroupsToFirebase().catch(error => {
                console.error('ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
            });

            cancelAdjustMode();
            updateCoordinatesList();
            updateGroupsList();
            updateStats();
            drawMap();
            
            alert('èª¿æ•´åº§æ¨™ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
        }
        
        // åº§æ¨™èª¿æ•´ãƒ¢ãƒ¼ãƒ‰ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        function cancelAdjustMode() {
            adjustMode.active = false;
            adjustMode.coordinates = [];
            adjustMode.groupName = '';
            document.getElementById('adjustModePanel').style.display = 'none';
            changeMode('view');
        }
        
        // ãƒã‚¦ã‚¹ãƒ€ã‚¦ãƒ³
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const worldPos = screenToWorld(x, y);

            // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ãƒ‘ãƒ³æ“ä½œã‚’å„ªå…ˆ
            if (isSpaceKeyPressed) {
                isPanning = true;
                lastPanPos = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
                return;
            }

            if (currentMode === 'view') {
                // ä¿®æ­£5: ã²ã—å½¢ãƒ¢ãƒ¼ãƒ‰ã§ã®ãƒ‘ãƒ³æ“ä½œ
                isPanning = true;
                lastPanPos = { x: e.clientX, y: e.clientY };
            } else if (currentMode === 'input') {
                if (selectedObstacleType) {
                    const customObstacle = customObstacles.find(o => o.id === selectedObstacleType);
                    if (customObstacle && selectedObstacleType !== 'temp_custom') {
                        handleInputClick(worldPos);
                    } else {
                        isDragging = true;
                        dragStartCell = worldPos;
                        dragCurrentCell = worldPos;
                        
                        const key = `${worldPos.x},${worldPos.y}`;
                        const existingObstacle = obstacles.find(o => o.cells.includes(key) && o.type === selectedObstacleType);
                        dragStartCell.isObstacle = !!existingObstacle;
                    }
                } else {
                    handleInputClick(worldPos);
                }
            } else if (currentMode === 'adjust') {
                handleAdjustStart(worldPos, { x, y });
            } else if (currentMode === 'delete') {
                if (selectedObstacleType) {
                    isDragging = true;
                    dragStartCell = worldPos;
                    dragCurrentCell = worldPos;
                } else {
                    handleDeleteClick(worldPos);
                }
            }
        }
        
        // ãƒã‚¦ã‚¹ãƒ ãƒ¼ãƒ–
        function handleMouseMove(e) {
            // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼æŠ¼ä¸‹ä¸­ã¾ãŸã¯ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã®ãƒ‘ãƒ³æ“ä½œ
            if (isPanning && lastPanPos) {
                // ä¿®æ­£5: ã²ã—å½¢ãƒ¢ãƒ¼ãƒ‰ã§ã‚‚ç”»é¢åº§æ¨™ç³»ã§ãƒ‘ãƒ³æ“ä½œ
                const dx = e.clientX - lastPanPos.x;
                const dy = e.clientY - lastPanPos.y;
                
                if (gridType === 'diamond') {
                    // ã²ã—å½¢ãƒ¢ãƒ¼ãƒ‰: ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã®ç§»å‹•é‡ã‚’ä¸–ç•Œåº§æ¨™ã«å¤‰æ›
                    const screenDelta = { x: dx, y: dy };
                    const worldDelta = screenToWorldDelta(screenDelta);
                    offsetX -= worldDelta.x;
                    offsetY -= worldDelta.y;
                } else {
                    // æ­£æ–¹å½¢ãƒ¢ãƒ¼ãƒ‰: å¾“æ¥é€šã‚Š
                    offsetX -= dy / scale;
                    offsetY -= dx / scale;
                }
                
                lastPanPos = { x: e.clientX, y: e.clientY };
                drawMap();
            } else if ((currentMode === 'input' || currentMode === 'delete') && isDragging && dragStartCell) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = screenToWorld(x, y);
                
                dragCurrentCell = worldPos;
                updateDragSelection();
                drawMap();
            } else if (currentMode === 'adjust' && draggedCoordinate) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = screenToWorld(x, y);
                
                draggedCoordinate.x = worldPos.x;
                draggedCoordinate.y = worldPos.y;
                drawMap();
            }
        }
        
        // ä¿®æ­£5: ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã®ãƒ‡ãƒ«ã‚¿ã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã®ãƒ‡ãƒ«ã‚¿ã«å¤‰æ›
        function screenToWorldDelta(screenDelta) {
            if (gridType === 'diamond') {
                const sx = screenDelta.x / scale * 2;
                const sy = screenDelta.y / scale / 0.876 * 2;
                
                return {
                    x: (sx + sy) / 2,
                    y: (sx - sy) / 2
                };
            } else {
                return {
                    x: screenDelta.y / scale,
                    y: screenDelta.x / scale
                };
            }
        }
        
        // ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—
        function handleMouseUp(e) {
            // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼æŠ¼ä¸‹ä¸­ã®ãƒ‘ãƒ³æ“ä½œçµ‚äº†
            if (isSpaceKeyPressed && isPanning) {
                isPanning = false;
                lastPanPos = null;
                canvas.style.cursor = 'grab';
                return;
            }

            if (currentMode === 'view') {
                isPanning = false;
                lastPanPos = null;
            } else if ((currentMode === 'input' || currentMode === 'delete') && isDragging) {
                if (dragStartCell && dragCurrentCell && 
                    dragStartCell.x === dragCurrentCell.x && 
                    dragStartCell.y === dragCurrentCell.y) {
                    updateDragSelection();
                }
                
                if (selectedObstacleType && selectedObstacleType !== 'temp_custom') {
                    // ä¿®æ­£1: currentModeã‚’å¼•æ•°ã¨ã—ã¦æ¸¡ã™
                    confirmDragObstacle(currentMode);
                }
                isDragging = false;
                dragStartCell = null;
                dragCurrentCell = null;
            } else if (currentMode === 'adjust' && draggedCoordinate) {
                draggedCoordinate = null;
                drawMap();
            }
        }

        // ã‚­ãƒ¼ãƒ€ã‚¦ãƒ³ï¼ˆã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼æ¤œå‡ºï¼‰
        function handleKeyDown(e) {
            if (e.code === 'Space') {
                // å…¥åŠ›æ¬„ã‚„ãƒœã‚¿ãƒ³ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãŒã‚ã‚‹å ´åˆã¯ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã‚’ç„¡è¦–
                const activeTag = document.activeElement.tagName;
                if (activeTag === 'INPUT' ||
                    activeTag === 'TEXTAREA' ||
                    activeTag === 'BUTTON' ||
                    activeTag === 'SELECT' ||
                    activeTag === 'A') {
                    return;
                }

                // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œï¼ˆãƒšãƒ¼ã‚¸ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰ã‚’é˜²ã
                e.preventDefault();

                if (!isSpaceKeyPressed) {
                    isSpaceKeyPressed = true;
                    canvas.style.cursor = 'grab';
                }
            }
        }

        // ã‚­ãƒ¼ã‚¢ãƒƒãƒ—ï¼ˆã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼è§£é™¤ï¼‰
        function handleKeyUp(e) {
            if (e.code === 'Space') {
                e.preventDefault();
                isSpaceKeyPressed = false;
                isPanning = false;
                lastPanPos = null;
                canvas.style.cursor = 'default';
            }
        }

        // ãƒ‰ãƒ©ãƒƒã‚°é¸æŠã®æ›´æ–°
        function updateDragSelection() {
            if (!dragStartCell || !dragCurrentCell) return;
            
            tempSelection.clear();
            
            const minX = Math.min(dragStartCell.x, dragCurrentCell.x);
            const maxX = Math.max(dragStartCell.x, dragCurrentCell.x);
            const minY = Math.min(dragStartCell.y, dragCurrentCell.y);
            const maxY = Math.max(dragStartCell.y, dragCurrentCell.y);
            
            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    const key = `${x},${y}`;
                    tempSelection.add(key);
                }
            }
        }
        
        // ä¿®æ­£1: ãƒ‰ãƒ©ãƒƒã‚°éšœå®³ç‰©ã®ç¢ºå®š - currentModeã‚’å¼•æ•°ã¨ã—ã¦å—ã‘å–ã‚‹
        function confirmDragObstacle(mode) {
            if (tempSelection.size === 0) return;

            // ä¿®æ­£1: dragStartCell.isObstacleã§ã¯ãªãmodeã‹ã‚‰åˆ¤å®š
            const isAddMode = (mode !== 'delete');

            if (isAddMode) {
                // è¿½åŠ ãƒ¢ãƒ¼ãƒ‰ï¼šé¸æŠã—ãŸã‚»ãƒ«ã‚’æ–°ã—ã„éšœå®³ç‰©ã¨ã—ã¦ä½œæˆ
                const newCells = [];
                tempSelection.forEach(key => {
                    const existingObstacle = obstacles.find(o => o.cells.includes(key) && o.type === selectedObstacleType);
                    if (!existingObstacle) {
                        newCells.push(key);
                    }
                });

                // æ–°ã—ã„ã‚»ãƒ«ãŒã‚ã‚Œã°ã€æ–°ã—ã„éšœå®³ç‰©ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
                if (newCells.length > 0) {
                    obstacles.push({
                        id: Date.now().toString() + '-' + Math.floor(Math.random() * 1000000),
                        type: selectedObstacleType,
                        cells: newCells
                    });
                }
            } else {
                // å‰Šé™¤ãƒ¢ãƒ¼ãƒ‰ï¼šæ—¢å­˜ã®éšœå®³ç‰©ã‹ã‚‰ã‚»ãƒ«ã‚’å‰Šé™¤
                tempSelection.forEach(key => {
                    const existingObstacle = obstacles.find(o => o.cells.includes(key) && o.type === selectedObstacleType);
                    if (existingObstacle) {
                        existingObstacle.cells = existingObstacle.cells.filter(c => c !== key);
                    }
                });
            }
            
            obstacles = obstacles.filter(o => o.cells.length > 0);

            // Firebaseã«éšœå®³ç‰©ã‚’ä¿å­˜
            saveObstaclesToFirebase().catch(error => {
                console.error('éšœå®³ç‰©ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
            });

            tempSelection.clear();
            groupObstacles();
            updateObstaclesList();
            updateStats();
            drawMap();
        }
        
        // ãƒ›ã‚¤ãƒ¼ãƒ«(ã‚ºãƒ¼ãƒ )
        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            scale = Math.max(0.5, Math.min(20, scale * delta));
            drawMap();
        }
        
        // ã‚¿ãƒƒãƒã‚¹ã‚¿ãƒ¼ãƒˆ
        function handleTouchStart(e) {
            e.preventDefault();
            touches = Array.from(e.touches);

            if (touches.length === 1) {
                const touch = touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                const worldPos = screenToWorld(x, y);

                // é–²è¦§ãƒ¢ãƒ¼ãƒ‰ã§ã¯1æœ¬æŒ‡ã§ãƒ‘ãƒ³å¯èƒ½
                if (currentMode === 'view') {
                    lastPanPos = { x: touch.clientX, y: touch.clientY };
                    isPanning = true;
                } else if (currentMode === 'input') {
                    if (selectedObstacleType) {
                        const customObstacle = customObstacles.find(o => o.id === selectedObstacleType);
                        if (customObstacle && selectedObstacleType !== 'temp_custom') {
                            handleInputClick(worldPos);
                        } else {
                            isDragging = true;
                            dragStartCell = worldPos;
                            dragCurrentCell = worldPos;
                            
                            const key = `${worldPos.x},${worldPos.y}`;
                            const existingObstacle = obstacles.find(o => o.cells.includes(key) && o.type === selectedObstacleType);
                            dragStartCell.isObstacle = !!existingObstacle;
                        }
                    } else {
                        handleInputClick(worldPos);
                    }
                } else if (currentMode === 'adjust') {
                    handleAdjustStart(worldPos, { x, y });
                } else if (currentMode === 'delete') {
                    if (selectedObstacleType) {
                        isDragging = true;
                        dragStartCell = worldPos;
                        dragCurrentCell = worldPos;
                    } else {
                        handleDeleteClick(worldPos);
                    }
                }
            } else if (touches.length === 2) {
                const dx = touches[1].clientX - touches[0].clientX;
                const dy = touches[1].clientY - touches[0].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                
                const centerX = (touches[0].clientX + touches[1].clientX) / 2;
                const centerY = (touches[0].clientY + touches[1].clientY) / 2;
                lastPanPos = { x: centerX, y: centerY };
                isPanning = true;
            }
        }
        
        // ã‚¿ãƒƒãƒãƒ ãƒ¼ãƒ–
        function handleTouchMove(e) {
            e.preventDefault();
            touches = Array.from(e.touches);
            
            if (touches.length === 2) {
                const dx = touches[1].clientX - touches[0].clientX;
                const dy = touches[1].clientY - touches[0].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (lastTouchDistance > 0) {
                    const delta = distance / lastTouchDistance;
                    scale = Math.max(0.5, Math.min(20, scale * delta));
                }
                lastTouchDistance = distance;
                
                if (isPanning && lastPanPos) {
                    const centerX = (touches[0].clientX + touches[1].clientX) / 2;
                    const centerY = (touches[0].clientY + touches[1].clientY) / 2;
                    
                    const panDx = centerX - lastPanPos.x;
                    const panDy = centerY - lastPanPos.y;
                    
                    // ä¿®æ­£5: ã‚¿ãƒƒãƒãƒ‘ãƒ³æ“ä½œã‚‚ã²ã—å½¢ãƒ¢ãƒ¼ãƒ‰ã«å¯¾å¿œ
                    if (gridType === 'diamond') {
                        const screenDelta = { x: panDx, y: panDy };
                        const worldDelta = screenToWorldDelta(screenDelta);
                        offsetX -= worldDelta.x;
                        offsetY -= worldDelta.y;
                    } else {
                        offsetX -= panDy / scale;
                        offsetY -= panDx / scale;
                    }
                    
                    lastPanPos = { x: centerX, y: centerY };
                }
                
                drawMap();
            } else if (touches.length === 1) {
                const touch = touches[0];

                // é–²è¦§ãƒ¢ãƒ¼ãƒ‰ã§ã®1æœ¬æŒ‡ãƒ‘ãƒ³
                if (currentMode === 'view' && isPanning && lastPanPos) {
                    const panDx = touch.clientX - lastPanPos.x;
                    const panDy = touch.clientY - lastPanPos.y;

                    if (gridType === 'diamond') {
                        const screenDelta = { x: panDx, y: panDy };
                        const worldDelta = screenToWorldDelta(screenDelta);
                        offsetX -= worldDelta.x;
                        offsetY -= worldDelta.y;
                    } else {
                        offsetX -= panDy / scale;
                        offsetY -= panDx / scale;
                    }

                    lastPanPos = { x: touch.clientX, y: touch.clientY };
                    drawMap();
                } else if ((currentMode === 'input' || currentMode === 'delete') && isDragging && dragStartCell) {
                    const rect = canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    const worldPos = screenToWorld(x, y);

                    dragCurrentCell = worldPos;
                    updateDragSelection();
                    drawMap();
                } else if (currentMode === 'adjust' && draggedCoordinate) {
                    const rect = canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    const worldPos = screenToWorld(x, y);

                    draggedCoordinate.x = worldPos.x;
                    draggedCoordinate.y = worldPos.y;
                    drawMap();
                }
            }
        }
        
        // ã‚¿ãƒƒãƒã‚¨ãƒ³ãƒ‰
        function handleTouchEnd(e) {
            e.preventDefault();
            touches = Array.from(e.touches);
            
            if (touches.length < 2) {
                lastTouchDistance = 0;
                isPanning = false;
                lastPanPos = null;
            }
            
            if (touches.length === 0) {
                if ((currentMode === 'input' || currentMode === 'delete') && isDragging) {
                    if (dragStartCell && dragCurrentCell && 
                        dragStartCell.x === dragCurrentCell.x && 
                        dragStartCell.y === dragCurrentCell.y) {
                        updateDragSelection();
                    }
                    
                    if (selectedObstacleType && selectedObstacleType !== 'temp_custom') {
                        // ä¿®æ­£1: currentModeã‚’å¼•æ•°ã¨ã—ã¦æ¸¡ã™
                        confirmDragObstacle(currentMode);
                    }
                    isDragging = false;
                    dragStartCell = null;
                    dragCurrentCell = null;
                } else if (currentMode === 'adjust' && draggedCoordinate) {
                    draggedCoordinate = null;
                    drawMap();
                }
            }
        }
        
        // å…¥åŠ›ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        function handleInputClick(worldPos) {
            if (!selectedObstacleType) return;
            
            const key = `${worldPos.x},${worldPos.y}`;
            
            const customObstacle = customObstacles.find(o => o.id === selectedObstacleType);
            if (customObstacle && customObstacle.shape && customObstacle.shape.length > 0) {
                customObstacle.shape.forEach(cell => {
                    const [dx, dy] = cell.split(',').map(Number);
                    const targetKey = `${worldPos.x + dx},${worldPos.y + dy}`;
                    tempSelection.add(targetKey);
                });
                
                if (selectedObstacleType !== 'temp_custom') {
                    // ä¿®æ­£1: currentModeã‚’å¼•æ•°ã¨ã—ã¦æ¸¡ã™
                    confirmDragObstacle(currentMode);
                }
            }
        }
        
        // åº§æ¨™èª¿æ•´é–‹å§‹
        function handleAdjustStart(worldPos, screenPos) {
            const dataSource = adjustMode.active ? adjustMode.coordinates : savedCoordinates;
            const hitRadius = 10;
            
            let closestCoord = null;
            let minDistance = Infinity;
            
            for (const coord of dataSource) {
                if (!adjustMode.active && hiddenCoordinateIds.has(coord.id)) continue;
                
                const dx = coord.x - worldPos.x;
                const dy = coord.y - worldPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (Math.abs(dx) <= hitRadius && Math.abs(dy) <= hitRadius) {
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestCoord = coord;
                    }
                }
            }
            
            if (closestCoord) {
                draggedCoordinate = closestCoord;
            }
        }
        
        // å‰Šé™¤ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        function handleDeleteClick(worldPos) {
            const coord = savedCoordinates.find(c => c.x === worldPos.x && c.y === worldPos.y);
            if (coord) {
                if (confirm(`${coord.name} ã‚’å‰Šé™¤ã—ã¾ã™ã‹?`)) {
                    savedCoordinates = savedCoordinates.filter(c => c.id !== coord.id);
                    selectedCoordinateIds.delete(coord.id);
                    updateCoordinatesList();
                    updateStats();
                    drawMap();
                }
            }
        }
        
        // ãƒãƒƒãƒ—æç”»
        function drawMap() {
            const dpr = window.devicePixelRatio || 1;
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;
            
            ctx.clearRect(0, 0, width, height);
            
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(0, 0, width, height);
            
            drawPrimeZoneBackground();
            
            if (gridType === 'diamond') {
                drawDiamondGrid();
            } else {
                drawSquareGrid();
            }
            
            castles.forEach(castle => {
                drawCastle(castle);
            });
            
            const coordsToDisplay = adjustMode.active ? adjustMode.coordinates : savedCoordinates;
            
            coordsToDisplay.forEach(coord => {
                if (!adjustMode.active && hiddenCoordinateIds.has(coord.id)) return;
                drawResidenceArea(coord);
            });
            
            obstacles.forEach(obstacle => {
                drawObstacle(obstacle);
            });
            
            if ((currentMode === 'input' || currentMode === 'delete') && tempSelection.size > 0) {
                tempSelection.forEach(key => {
                    const [x, y] = key.split(',').map(Number);
                    const color = isCreatingCustomObstacle && customObstacleInProgress 
                        ? customObstacleInProgress.color 
                        : (selectedObstacleType ? getObstacleColor(selectedObstacleType) : 'rgba(255, 0, 0, 0.3)');
                    drawCell(x, y, color);
                });
            }
            
            coordsToDisplay.forEach(coord => {
                if (!adjustMode.active && hiddenCoordinateIds.has(coord.id)) return;
                drawCoordinateMarker(coord);
            });
            
            if (draggedCoordinate) {
                drawCoordinateMarker(draggedCoordinate, true);
            }
        }
        
        // ä¸€ç´šåœ°å¸¯ã®èƒŒæ™¯æç”»
        function drawPrimeZoneBackground() {
            if (gridType === 'diamond') {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.15)';
                ctx.beginPath();
                
                const topLeft = worldToScreen(primeZone.minX, primeZone.minY);
                const topRight = worldToScreen(primeZone.minX, primeZone.maxY + 1);
                const bottomRight = worldToScreen(primeZone.maxX + 1, primeZone.maxY + 1);
                const bottomLeft = worldToScreen(primeZone.maxX + 1, primeZone.minY);
                
                ctx.moveTo(topLeft.x, topLeft.y);
                ctx.lineTo(topRight.x, topRight.y);
                ctx.lineTo(bottomRight.x, bottomRight.y);
                ctx.lineTo(bottomLeft.x, bottomLeft.y);
                ctx.closePath();
                ctx.fill();
            } else {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.15)';
                const pos1 = worldToScreen(primeZone.minX, primeZone.minY);
                const pos2 = worldToScreen(primeZone.maxX + 1, primeZone.maxY + 1);
                ctx.fillRect(pos1.x, pos1.y, pos2.x - pos1.x, pos2.y - pos1.y);
            }
        }
        
        // æ­£æ–¹å½¢ã‚°ãƒªãƒƒãƒ‰æç”»
        function drawSquareGrid() {
            const dpr = window.devicePixelRatio || 1;
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;
            
            ctx.lineWidth = 1;
            
            const visibleMinX = Math.floor(offsetX - height / scale / 2);
            const visibleMaxX = Math.ceil(offsetX + height / scale / 2);
            const visibleMinY = Math.floor(offsetY - width / scale / 2);
            const visibleMaxY = Math.ceil(offsetY + width / scale / 2);
            
            for (let x = Math.max(worldBounds.minX, visibleMinX); x <= Math.min(worldBounds.maxX, visibleMaxX) + 1; x++) {
                const pos1 = worldToScreen(x, visibleMinY);
                const pos2 = worldToScreen(x, visibleMaxY);
                
                ctx.strokeStyle = x % 10 === 0 ? '#888' : '#d0d0d0';
                ctx.beginPath();
                ctx.moveTo(pos1.x, Math.floor(pos1.y) + 0.5);
                ctx.lineTo(pos2.x, Math.floor(pos2.y) + 0.5);
                ctx.stroke();
            }
            
            for (let y = Math.max(worldBounds.minY, visibleMinY); y <= Math.min(worldBounds.maxY, visibleMaxY) + 1; y++) {
                const pos1 = worldToScreen(visibleMinX, y);
                const pos2 = worldToScreen(visibleMaxX, y);
                
                ctx.strokeStyle = y % 10 === 0 ? '#888' : '#d0d0d0';
                ctx.beginPath();
                ctx.moveTo(Math.floor(pos1.x) + 0.5, pos1.y);
                ctx.lineTo(Math.floor(pos2.x) + 0.5, pos2.y);
                ctx.stroke();
            }
        }
        
        // ã²ã—å½¢ã‚°ãƒªãƒƒãƒ‰æç”»
        function drawDiamondGrid() {
            const dpr = window.devicePixelRatio || 1;
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;
            
            ctx.lineWidth = 1;
            
            const visibleRange = Math.max(width, height) / scale + 50;
            const visibleMinX = Math.floor(offsetX - visibleRange);
            const visibleMaxX = Math.ceil(offsetX + visibleRange);
            const visibleMinY = Math.floor(offsetY - visibleRange);
            const visibleMaxY = Math.ceil(offsetY + visibleRange);
            
            for (let x = Math.max(worldBounds.minX, visibleMinX); x <= Math.min(worldBounds.maxX, visibleMaxX) + 1; x++) {
                for (let y = Math.max(worldBounds.minY, visibleMinY); y <= Math.min(worldBounds.maxY, visibleMaxY) + 1; y++) {
                    const pos = worldToScreen(x, y);
                    
                    if (pos.x < -100 || pos.x > width + 100 || pos.y < -100 || pos.y > height + 100) {
                        continue;
                    }
                    
                    ctx.strokeStyle = (x % 10 === 0 || y % 10 === 0) ? '#888' : '#d0d0d0';
                    
                    if (y <= Math.min(worldBounds.maxY, visibleMaxY)) {
                        const posRight = worldToScreen(x, y + 1);
                        ctx.beginPath();
                        ctx.moveTo(Math.floor(pos.x) + 0.5, Math.floor(pos.y) + 0.5);
                        ctx.lineTo(Math.floor(posRight.x) + 0.5, Math.floor(posRight.y) + 0.5);
                        ctx.stroke();
                    }
                    
                    if (x <= Math.min(worldBounds.maxX, visibleMaxX)) {
                        const posDown = worldToScreen(x + 1, y);
                        ctx.beginPath();
                        ctx.moveTo(Math.floor(pos.x) + 0.5, Math.floor(pos.y) + 0.5);
                        ctx.lineTo(Math.floor(posDown.x) + 0.5, Math.floor(posDown.y) + 0.5);
                        ctx.stroke();
                    }
                }
            }
        }
        
        // ã‚»ãƒ«æç”»
        function drawCell(x, y, color) {
            if (gridType === 'diamond') {
                drawDiamondCell(x, y, color);
            } else {
                drawSquareCell(x, y, color);
            }
        }
        
        // æ­£æ–¹å½¢ã‚»ãƒ«æç”»
        function drawSquareCell(x, y, color) {
            const topLeft = worldToScreen(x, y);
            const bottomRight = worldToScreen(x + 1, y + 1);
            const width = bottomRight.x - topLeft.x;
            const height = bottomRight.y - topLeft.y;
            
            ctx.fillStyle = color;
            ctx.fillRect(topLeft.x, topLeft.y, width, height);
        }
        
        // ã²ã—å½¢ã‚»ãƒ«æç”»
        function drawDiamondCell(x, y, color) {
            const topLeft = worldToScreen(x, y);
            const topRight = worldToScreen(x, y + 1);
            const bottomRight = worldToScreen(x + 1, y + 1);
            const bottomLeft = worldToScreen(x + 1, y);
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(topLeft.x, topLeft.y);
            ctx.lineTo(topRight.x, topRight.y);
            ctx.lineTo(bottomRight.x, bottomRight.y);
            ctx.lineTo(bottomLeft.x, bottomLeft.y);
            ctx.closePath();
            ctx.fill();
        }
        
        // åŸã®æç”»
        function drawCastle(castle) {
            const { x, y, name } = castle;

            for (let dx = -4; dx <= 4; dx++) {
                for (let dy = -4; dy <= 4; dy++) {
                    drawCell(x + dx, y + dy, 'rgba(128, 0, 128, 0.6)');
                }
            }

            for (let dx = -8; dx <= 8; dx++) {
                for (let dy = -8; dy <= 8; dy++) {
                    if (Math.abs(dx) > 4 || Math.abs(dy) > 4) {
                        drawCell(x + dx, y + dy, 'rgba(200, 150, 200, 0.3)');
                    }
                }
            }

            // åŸã®åå‰ã‚’è¡¨ç¤º
            const screenPos = worldToScreen(x, y);
            ctx.save();
            ctx.font = `bold ${Math.max(12, scale * 2)}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // èƒŒæ™¯ï¼ˆç™½ã„å½±ï¼‰ã‚’æç”»ã—ã¦èª­ã¿ã‚„ã™ãã™ã‚‹
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.strokeText(name, screenPos.x, screenPos.y);

            // ãƒ†ã‚­ã‚¹ãƒˆã‚’æç”»
            ctx.fillStyle = '#800080';
            ctx.fillText(name, screenPos.x, screenPos.y);
            ctx.restore();
        }
        
        // å±…ä½ç¯„å›²ã®æç”»
        function drawResidenceArea(coord) {
            const { x, y } = coord;
            const range = 10;
            
            for (let dx = -range; dx <= range; dx++) {
                for (let dy = -range; dy <= range; dy++) {
                    drawCell(x + dx, y + dy, 'rgba(100, 200, 100, 0.1)');
                }
            }
        }
        
        // éšœå®³ç‰©ã®è‰²å–å¾—
        function getObstacleColor(type) {
            if (type === 'rock') {
                return 'rgba(128, 128, 128, 0.6)';
            }
            
            const custom = customObstacles.find(o => o.id === type);
            if (custom) {
                const color = custom.color;
                
                if (color.startsWith('#')) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.6)`;
                }
                
                const rgb = color.match(/\d+/g);
                if (rgb && rgb.length >= 3) {
                    return `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.6)`;
                }
                
                return color;
            }
            
            return 'rgba(128, 128, 128, 0.6)';
        }
        
        // éšœå®³ç‰©æç”»
        function drawObstacle(obstacle) {
            const color = getObstacleColor(obstacle.type);
            
            obstacle.cells.forEach(cell => {
                const [x, y] = cell.split(',').map(Number);
                drawCell(x, y, color);
            });
        }
        
        // åº§æ¨™ãƒãƒ¼ã‚«ãƒ¼æç”»
        function drawCoordinateMarker(coord, isDragging = false) {
            const pos = gridType === 'diamond' 
                ? worldToScreen(coord.x + 0.5, coord.y + 0.5)
                : worldToScreen(coord.x + 0.5, coord.y + 0.5);
            const size = Math.min(scale * 0.8, 30);
            
            ctx.fillStyle = isDragging ? '#ff9800' : '#ff4444';
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, size / 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            if (scale > 2) {
                const fontSize = Math.min(scale * 2, 14);
                ctx.font = `bold ${fontSize}px sans-serif`;
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const name = coord.name.length > 10 ? coord.name.substring(0, 10) + '...' : coord.name;
                
                const metrics = ctx.measureText(name);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fillRect(pos.x - metrics.width / 2 - 2, pos.y - fontSize / 2 - 2, metrics.width + 4, fontSize + 4);
                
                ctx.fillStyle = '#000000';
                ctx.fillText(name, pos.x, pos.y);
            }
        }
        
        // åº§æ¨™è§£æ
        function parseCoordinates() {
            const input = document.getElementById('coordInput').value.trim();
            if (!input) {
                alert('åº§æ¨™ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            parsedCoordinates = [];
            
            const customDelim = document.getElementById('customDelimiter').value.trim();
            let entries;
            
            if (customDelim) {
                entries = input.split(customDelim);
            } else {
                entries = input.split(/[\nã€,]/);
            }
            
            entries.forEach((entry, index) => {
                entry = entry.trim();
                if (!entry) return;
                
                let match = entry.match(/^(.+?)[::]?\s*[@@ ]\s*(\d+)\s+(\d+)/);
                if (match) {
                    parsedCoordinates.push({
                        name: match[1].trim().replace(/[::] $/, ''),
                        x: parseInt(match[2]),
                        y: parseInt(match[3])
                    });
                    return;
                }
                
                match = entry.match(/^(\d+)\s+(\d+)/);
                if (match) {
                    parsedCoordinates.push({
                        name: `åº§æ¨™${parsedCoordinates.length + 1}`,
                        x: parseInt(match[1]),
                        y: parseInt(match[2])
                    });
                    return;
                }
            });
            
            if (parsedCoordinates.length === 0) {
                alert('æœ‰åŠ¹ãªåº§æ¨™ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
                return;
            }
            
            alert(`${parsedCoordinates.length}ä»¶ã®åº§æ¨™ã‚’è§£æã—ã¾ã—ãŸ`);
            displayParseResult();
        }
        
        // è§£æçµæœè¡¨ç¤º
        function displayParseResult() {
            const section = document.getElementById('parseResultSection');
            const container = document.getElementById('parseResult');
            
            section.style.display = 'block';
            container.innerHTML = '';
            
            parsedCoordinates.forEach((coord, idx) => {
                const div = document.createElement('div');
                div.className = 'parse-result-item';
                div.innerHTML = `
                    <input type="text" class="name-input" value="${coord.name}" 
                           onchange="updateParsedCoordinate(${idx}, 'name', this.value)">
                    <span>@</span>
                    <input type="number" class="coord-input" value="${coord.x}" min="0" max="700"
                           onchange="updateParsedCoordinate(${idx}, 'x', this.value)">
                    <input type="number" class="coord-input" value="${coord.y}" min="0" max="1900"
                           onchange="updateParsedCoordinate(${idx}, 'y', this.value)">
                `;
                container.appendChild(div);
            });
        }
        
        // è§£ææ¸ˆã¿åº§æ¨™ã®æ›´æ–°
        function updateParsedCoordinate(index, field, value) {
            if (field === 'name') {
                parsedCoordinates[index].name = value;
            } else if (field === 'x') {
                parsedCoordinates[index].x = parseInt(value);
            } else if (field === 'y') {
                parsedCoordinates[index].y = parseInt(value);
            }
        }
        
        // è§£æçµæœã‚’ã‚¯ãƒªã‚¢
        function clearParseResult() {
            parsedCoordinates = [];
            document.getElementById('parseResultSection').style.display = 'none';
            document.getElementById('coordInput').value = '';
            document.getElementById('coordInputGroupName').value = '';
        }
        
        // åº§æ¨™ã‚’ä¿å­˜
        function saveCoordinates() {
            if (parsedCoordinates.length === 0) {
                alert('è§£æçµæœãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }

            // ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å–å¾—
            const groupName = document.getElementById('coordInputGroupName').value.trim();

            // ã‚¹ãƒ†ãƒƒãƒ—1: å…¥åŠ›ãƒ‡ãƒ¼ã‚¿å†…ã§ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
            const inputDuplicates = [];
            const inputUnique = [];
            const seenCoords = new Map(); // ã‚­ãƒ¼: "x,y", å€¤: æœ€åˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹

            parsedCoordinates.forEach((coord, index) => {
                const key = `${coord.x},${coord.y}`;
                if (seenCoords.has(key)) {
                    inputDuplicates.push(coord);
                } else {
                    seenCoords.set(key, index);
                    inputUnique.push(coord);
                }
            });

            // å…¥åŠ›ãƒ‡ãƒ¼ã‚¿å†…ã«é‡è¤‡ãŒã‚ã‚‹å ´åˆã®ç¢ºèª
            if (inputDuplicates.length > 0) {
                const saveInputDuplicates = confirm(
                    `å…¥åŠ›ãƒ‡ãƒ¼ã‚¿å†…ã«é‡è¤‡åº§æ¨™ãŒ${inputDuplicates.length}ä»¶ã‚ã‚Šã¾ã™ã€‚\n` +
                    `${parsedCoordinates.length}ä»¶ä¸­${inputUnique.length}ä»¶ãŒãƒ¦ãƒ‹ãƒ¼ã‚¯ãªåº§æ¨™ã§ã™ã€‚\n\n` +
                    `é‡è¤‡ãƒ‡ãƒ¼ã‚¿ã‚‚å«ã‚ã¦ä¿å­˜ã—ã¾ã™ã‹?\n` +
                    `(é‡è¤‡ãƒ‡ãƒ¼ã‚¿ã¯ã€ãƒãƒƒãƒ—ã«ã¯è¡¨ç¤ºã›ãšã«ä¿å­˜ã•ã‚Œã¾ã™)\n\n` +
                    `ã€ŒOKã€: é‡è¤‡ãƒ‡ãƒ¼ã‚¿ã‚‚ä¿å­˜\n` +
                    `ã€Œã‚­ãƒ£ãƒ³ã‚»ãƒ«ã€: é‡è¤‡ãƒ‡ãƒ¼ã‚¿ã‚’é™¤ã„ã¦ä¿å­˜`
                );

                if (!saveInputDuplicates) {
                    // é‡è¤‡ã‚’é™¤ã„ãŸãƒ‡ãƒ¼ã‚¿ã§ç¶šè¡Œ
                    parsedCoordinates = inputUnique;
                    displayParseResult();
                    alert(`é‡è¤‡ãƒ‡ãƒ¼ã‚¿ã‚’é™¤ã„ãŸ${inputUnique.length}ä»¶ã§å‡¦ç†ã‚’ç¶šã‘ã¾ã™`);
                }
            }

            // ã‚¹ãƒ†ãƒƒãƒ—2: æ—¢å­˜ã®ä¿å­˜æ¸ˆã¿åº§æ¨™ã¨ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
            const duplicates = [];
            const nonDuplicates = [];

            parsedCoordinates.forEach(coord => {
                const isDuplicate = savedCoordinates.some(saved =>
                    saved.x === coord.x && saved.y === coord.y
                );
                if (isDuplicate) {
                    duplicates.push(coord);
                } else {
                    nonDuplicates.push(coord);
                }
            });

            if (duplicates.length > 0) {
                const saveAll = confirm(
                    `æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã¨ã®é‡è¤‡ãŒ${duplicates.length}ä»¶ã‚ã‚Šã¾ã™ãŒã€ç™»éŒ²ã‚’è¡Œã„ã¾ã™ã‹?\n` +
                    `(é‡è¤‡ãƒ‡ãƒ¼ã‚¿ã¯ã€ãƒãƒƒãƒ—ã«ã¯è¡¨ç¤ºã›ãšã«ä¿å­˜ã•ã‚Œã¾ã™)`
                );

                if (saveAll) {
                    saveCoordsToDatabase(parsedCoordinates, duplicates, groupName);
                    clearParseResult();
                } else {
                    const saveNonDuplicates = confirm('é‡è¤‡ãƒ‡ãƒ¼ã‚¿ä»¥å¤–ã®ä¿å­˜ã‚’è¡Œã„ã¾ã™ã‹?');

                    if (saveNonDuplicates) {
                        saveCoordsToDatabase(nonDuplicates, [], groupName);

                        parsedCoordinates = duplicates;
                        displayParseResult();

                        alert(`${nonDuplicates.length}ä»¶/${parsedCoordinates.length + nonDuplicates.length}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
                    }
                }
            } else {
                saveCoordsToDatabase(parsedCoordinates, [], groupName);
                clearParseResult();
            }
        }
        
        // åº§æ¨™ã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜ã™ã‚‹å†…éƒ¨é–¢æ•°
        function saveCoordsToDatabase(coords, duplicates, groupName = null) {
            // ã‚°ãƒ«ãƒ¼ãƒ—åãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆã¾ãŸã¯å–å¾—
            let targetGroup = null;
            if (groupName && groupName.trim()) {
                targetGroup = coordinateGroups.find(g => g.name === groupName.trim());
                if (!targetGroup) {
                    // ã‚°ãƒ«ãƒ¼ãƒ—ãŒå­˜åœ¨ã—ãªã„å ´åˆã€æ–°è¦ä½œæˆ
                    targetGroup = {
                        id: Date.now().toString(),
                        name: groupName.trim(),
                        coordinateIds: []
                    };
                    coordinateGroups.push(targetGroup);
                }
            }

            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚°ãƒ«ãƒ¼ãƒ—
            const defaultGroup = coordinateGroups.find(g => g.id === 'default');

            // é‡è¤‡åº§æ¨™ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å–å¾—ã¾ãŸã¯ä½œæˆ
            let duplicateGroup = null;
            if (duplicates.length > 0) {
                duplicateGroup = coordinateGroups.find(g => g.name === 'é‡è¤‡åº§æ¨™');
                if (!duplicateGroup) {
                    duplicateGroup = {
                        id: 'duplicate-group-' + Date.now().toString(),
                        name: 'é‡è¤‡åº§æ¨™',
                        coordinateIds: []
                    };
                    coordinateGroups.push(duplicateGroup);
                }
            }

            const newCoordIds = [];
            coords.forEach(coord => {
                const newCoord = {
                    id: Date.now().toString() + '-' + Math.floor(Math.random() * 1000000),
                    name: coord.name,
                    x: coord.x,
                    y: coord.y,
                    createdAt: new Date().toISOString()
                };
                savedCoordinates.push(newCoord);
                newCoordIds.push(newCoord.id);

                // Firebaseã«åº§æ¨™ã‚’ä¿å­˜
                saveCoordinateToFirebase(newCoord).catch(error => {
                    console.error('åº§æ¨™ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                });

                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚°ãƒ«ãƒ¼ãƒ—ã«è¿½åŠ 
                if (defaultGroup) {
                    defaultGroup.coordinateIds.push(newCoord.id);
                }

                // æŒ‡å®šã•ã‚ŒãŸã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚‚è¿½åŠ 
                if (targetGroup) {
                    targetGroup.coordinateIds.push(newCoord.id);
                }

                const isDuplicate = duplicates.some(d => d.x === coord.x && d.y === coord.y);
                if (isDuplicate) {
                    hiddenCoordinateIds.add(newCoord.id);
                    duplicateCoordinateIds.add(newCoord.id);
                    // é‡è¤‡åº§æ¨™ã‚°ãƒ«ãƒ¼ãƒ—ã«è¿½åŠ 
                    if (duplicateGroup) {
                        duplicateGroup.coordinateIds.push(newCoord.id);
                    }
                }
            });

            // ã‚°ãƒ«ãƒ¼ãƒ—ã‚’Firebaseã«ä¿å­˜
            saveAllGroupsToFirebase().catch(error => {
                console.error('ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
            });

            updateCoordinatesList();
            updateGroupsList();
            updateStats();
            drawMap();

            if (coords.length > 0) {
                let message = `${coords.length}ä»¶ã®åº§æ¨™ã‚’ä¿å­˜ã—ã¾ã—ãŸ`;
                if (targetGroup) {
                    message += `\nã‚°ãƒ«ãƒ¼ãƒ—ã€Œ${targetGroup.name}ã€ã«è¿½åŠ ã—ã¾ã—ãŸ`;
                }
                alert(message);
            }
        }
        
        // ä¿®æ­£3+9: ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨ - isFilterActiveå¯¾å¿œ
        function applyFilters() {
            const nameFilter = document.getElementById('nameFilter').value.toLowerCase();
            const dateFrom = document.getElementById('dateFilterFrom').value;
            const dateTo = document.getElementById('dateFilterTo').value;
            const sortBy = document.getElementById('sortBy').value;
            
            // ãƒ•ã‚£ãƒ«ã‚¿ãŒé©ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            isFilterActive = !!(nameFilter || dateFrom || dateTo);
            
            if (!isFilterActive) {
                filteredCoordinates = [];
                updateFilterDisplay();
                updateCoordinatesList();
                return;
            }
            
            filteredCoordinates = savedCoordinates.filter(coord => {
                if (nameFilter && !coord.name.toLowerCase().includes(nameFilter)) {
                    return false;
                }
                
                if (coord.createdAt) {
                    const coordDate = coord.createdAt.split('T')[0];
                    if (dateFrom && coordDate < dateFrom) return false;
                    if (dateTo && coordDate > dateTo) return false;
                }
                
                return true;
            });
            
            filteredCoordinates.sort((a, b) => {
                switch (sortBy) {
                    case 'date-desc':
                        return (b.createdAt || '').localeCompare(a.createdAt || '');
                    case 'date-asc':
                        return (a.createdAt || '').localeCompare(b.createdAt || '');
                    case 'name-asc':
                        return a.name.localeCompare(b.name);
                    case 'name-desc':
                        return b.name.localeCompare(a.name);
                    case 'x-asc':
                        return a.x - b.x;
                    case 'x-desc':
                        return b.x - a.x;
                    case 'y-asc':
                        return a.y - b.y;
                    case 'y-desc':
                        return b.y - a.y;
                    default:
                        return 0;
                }
            });
            
            updateFilterDisplay();
            updateCoordinatesList();
        }
        

        // ãƒ•ã‚£ãƒ«ã‚¿è¡¨ç¤ºã‚’æ›´æ–°
        function updateFilterDisplay() {
            const container = document.getElementById('activeFiltersDisplay');
            if (!container) return;
            
            const nameFilter = document.getElementById('nameFilter').value;
            const dateFrom = document.getElementById('dateFilterFrom').value;
            const dateTo = document.getElementById('dateFilterTo').value;
            const sortBy = document.getElementById('sortBy').value;
            
            // ãƒ•ã‚£ãƒ«ã‚¿ã¾ãŸã¯ã‚°ãƒ«ãƒ¼ãƒ—ãŒé©ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const hasFilters = isFilterActive || groupFilterActive;
            
            if (!hasFilters) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'block';
            
            // ãƒ•ã‚£ãƒ«ã‚¿ä»¶æ•°ã‚’è¨ˆç®—
            let resultCount = 0;
            if (groupFilterActive && expandedGroupId) {
                const group = coordinateGroups.find(g => g.id === expandedGroupId);
                if (group) {
                    resultCount = savedCoordinates.filter(c => group.coordinateIds.includes(c.id)).length;
                }
            } else if (isFilterActive) {
                resultCount = filteredCoordinates.length;
            }
            
            // ãƒ˜ãƒƒãƒ€ãƒ¼éƒ¨åˆ†
            const headerHTML = `
                <div class="active-filters-header">
                    <span>ğŸ” é©ç”¨ä¸­ã®ãƒ•ã‚£ãƒ«ã‚¿:</span>
                    <span class="filter-count">(${resultCount}ä»¶è©²å½“)</span>
                </div>
            `;
            
            // ã‚¿ã‚°éƒ¨åˆ†
            let tagsHTML = '<div class="filter-tags">';
            
            // åå‰ãƒ•ã‚£ãƒ«ã‚¿
            if (nameFilter) {
                tagsHTML += `
                    <span class="filter-tag">
                        ğŸ”¤ åå‰: "${nameFilter}"
                        <button onclick="removeNameFilter()">âœ•</button>
                    </span>
                `;
            }
            
            // æ—¥ä»˜ãƒ•ã‚£ãƒ«ã‚¿
            if (dateFrom || dateTo) {
                let dateText = 'ğŸ“… æœŸé–“: ';
                if (dateFrom && dateTo) {
                    dateText += `${dateFrom}ï½${dateTo}`;
                } else if (dateFrom) {
                    dateText += `${dateFrom}ï½`;
                } else {
                    dateText += `ï½${dateTo}`;
                }
                tagsHTML += `
                    <span class="filter-tag">
                        ${dateText}
                        <button onclick="removeDateFilter()">âœ•</button>
                    </span>
                `;
            }
            
            // ã‚°ãƒ«ãƒ¼ãƒ—ãƒ•ã‚£ãƒ«ã‚¿
            if (groupFilterActive && expandedGroupId) {
                const group = coordinateGroups.find(g => g.id === expandedGroupId);
                if (group) {
                    tagsHTML += `
                        <span class="filter-tag">
                            ğŸ“¦ ã‚°ãƒ«ãƒ¼ãƒ—: ${group.name}
                            <button onclick="removeGroupFilter()">âœ•</button>
                        </span>
                    `;
                }
            }
            
            // ã‚½ãƒ¼ãƒˆé †ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä»¥å¤–ã®å ´åˆã®ã¿è¡¨ç¤ºï¼‰
            if (sortBy !== 'date-desc') {
                const sortLabels = {
                    'date-asc': 'ç™»éŒ²æ—¥æ™‚(å¤â†’æ–°)',
                    'name-asc': 'åå‰(Aâ†’Z)',
                    'name-desc': 'åå‰(Zâ†’A)',
                    'x-asc': 'Xåº§æ¨™(å°â†’å¤§)',
                    'x-desc': 'Xåº§æ¨™(å¤§â†’å°)',
                    'y-asc': 'Yåº§æ¨™(å°â†’å¤§)',
                    'y-desc': 'Yåº§æ¨™(å¤§â†’å°)'
                };
                tagsHTML += `
                    <span class="filter-tag">
                        â†“ ã‚½ãƒ¼ãƒˆ: ${sortLabels[sortBy] || sortBy}
                    </span>
                `;
            }
            
            // ã™ã¹ã¦ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³
            tagsHTML += `
                <button class="clear-all-filters-btn" onclick="clearFilters()">
                    ã™ã¹ã¦ã‚¯ãƒªã‚¢
                </button>
            `;
            
            tagsHTML += '</div>';
            
            container.innerHTML = headerHTML + tagsHTML;
        }
        
        // åå‰ãƒ•ã‚£ãƒ«ã‚¿ã‚’å‰Šé™¤
        function removeNameFilter() {
            document.getElementById('nameFilter').value = '';
            applyFilters();
        }
        
        // æ—¥ä»˜ãƒ•ã‚£ãƒ«ã‚¿ã‚’å‰Šé™¤
        function removeDateFilter() {
            document.getElementById('dateFilterFrom').value = '';
            document.getElementById('dateFilterTo').value = '';
            applyFilters();
        }
        
        // ã‚°ãƒ«ãƒ¼ãƒ—ãƒ•ã‚£ãƒ«ã‚¿ã‚’å‰Šé™¤
        function removeGroupFilter() {
            groupFilterActive = false;
            expandedGroupId = null;
            updateFilterDisplay();
            updateCoordinatesList();
            updateGroupsList();
        }
        
        // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚¯ãƒªã‚¢
        function clearFilters() {
            document.getElementById('nameFilter').value = '';
            document.getElementById('dateFilterFrom').value = '';
            document.getElementById('dateFilterTo').value = '';
            document.getElementById('sortBy').value = 'date-desc';
            filteredCoordinates = [];
            isFilterActive = false;
            groupFilterActive = false;
            expandedGroupId = null;
            updateFilterDisplay();
            updateCoordinatesList();
            updateGroupsList();
        }
        
        // åº§æ¨™ãƒªã‚¹ãƒˆæ›´æ–°
        function updateCoordinatesList() {
            const container = document.getElementById('coordinateList');
            container.innerHTML = '';
            
            // ãƒ•ã‚£ãƒ«ã‚¿è¡¨ç¤ºã‚’æ›´æ–°
            updateFilterDisplay();
            
            // è¡¨ç¤ºã™ã‚‹åº§æ¨™ã‚’æ±ºå®š
            let displayCoords;
            if (groupFilterActive && expandedGroupId) {
                const group = coordinateGroups.find(g => g.id === expandedGroupId);
                if (group) {
                    displayCoords = savedCoordinates.filter(c => group.coordinateIds.includes(c.id));
                } else {
                    displayCoords = savedCoordinates;
                }
            } else if (isFilterActive) {
                // ãƒ•ã‚£ãƒ«ã‚¿ãŒé©ç”¨ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€çµæœãŒ0ä»¶ã§ã‚‚filteredCoordinatesã‚’ä½¿ç”¨
                displayCoords = filteredCoordinates;
            } else {
                // ãƒ•ã‚£ãƒ«ã‚¿æœªé©ç”¨ã®å ´åˆã¯å…¨åº§æ¨™
                displayCoords = savedCoordinates;
            }
            
            // 0ä»¶ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¡¨ç¤º
            if (displayCoords.length === 0 && (isFilterActive || groupFilterActive)) {
                const noResults = document.createElement('div');
                noResults.className = 'no-results-message';
                noResults.textContent = 'è©²å½“ã™ã‚‹åº§æ¨™ãŒã‚ã‚Šã¾ã›ã‚“';
                container.appendChild(noResults);
                return;
            }
            
            if (displayCoords.length > 0) {
                const selectAllDiv = document.createElement('div');
                selectAllDiv.style.cssText = 'background: #e3f2fd; padding: 8px; margin-bottom: 8px; border-radius: 4px;';
                
                const allSelected = displayCoords.every(c => selectedCoordinateIds.has(c.id));
                
                selectAllDiv.innerHTML = `
                    <label style="cursor: pointer; font-weight: bold;">
                        <input type="checkbox" id="selectAllCoords" ${allSelected ? 'checked' : ''} onchange="toggleSelectAllCoordinates(this.checked)">
                        ã™ã¹ã¦é¸æŠ
                    </label>
                `;
                container.appendChild(selectAllDiv);
            }
            
            displayCoords.forEach(coord => {
                const div = document.createElement('div');
                div.className = 'coordinate-item';
                div.style.opacity = hiddenCoordinateIds.has(coord.id) ? '0.5' : '1';
                
                const isSelected = selectedCoordinateIds.has(coord.id);
                const createdDate = new Date(coord.createdAt).toLocaleDateString('ja-JP');
                const createdDateISO = coord.createdAt.split('T')[0];
                const isDuplicate = duplicateCoordinateIds.has(coord.id);
                
                div.innerHTML = `
                    <label style="display: flex; align-items: center; flex: 1;">
                        <input type="checkbox" ${isSelected ? 'checked' : ''} 
                               onchange="toggleCoordinateSelection(${coord.id}, this.checked)" onclick="event.stopPropagation()">
                        <span>
                            <a class="coordinate-name-link" onclick="jumpToCoordinate(${coord.id}); event.stopPropagation();">
                                ${coord.name}: @${coord.x} ${coord.y}
                            </a>
                            ${isDuplicate ? '<span style="color: #ff9800; font-size: 0.9em; margin-left: 4px;">[é‡è¤‡]</span>' : ''}
                            <a class="coordinate-name-link" onclick="filterByDate('${createdDateISO}'); event.stopPropagation();" style="margin-left: 4px;">
                                (${createdDate})
                            </a>
                        </span>
                    </label>
                    <div class="item-actions">
                        <button onclick="editCoordinate(${coord.id}); event.stopPropagation();">âœï¸</button>
                        <button onclick="deleteCoordinate(${coord.id}); event.stopPropagation();" 
                                style="background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);">ğŸ—‘ï¸</button>
                    </div>
                `;
                
                div.onclick = (e) => {
                    if (rangeSelectMode && !e.target.closest('button') && !e.target.closest('input[type="checkbox"]') && !e.target.closest('a')) {
                        handleRangeSelect(coord.id);
                    }
                };
                
                container.appendChild(div);
            });
        }
        
        // åº§æ¨™ã«ã‚¸ãƒ£ãƒ³ãƒ—
        function jumpToCoordinate(id) {
            const coord = savedCoordinates.find(c => c.id === id);
            if (!coord) return;
            
            offsetX = coord.x;
            offsetY = coord.y;
            scale = Math.max(scale, 5);
            drawMap();
        }
        
        // ä¸€ç´šåœ°å¸¯ã«ã‚¸ãƒ£ãƒ³ãƒ—
        function jumpToPrimeZone() {
            offsetX = (primeZone.minX + primeZone.maxX) / 2;
            offsetY = (primeZone.minY + primeZone.maxY) / 2;
            
            const dpr = window.devicePixelRatio || 1;
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;
            
            scale = Math.min(
                width / (primeZone.maxY - primeZone.minY + 20),
                height / (primeZone.maxX - primeZone.minX + 20)
            );
            
            drawMap();
        }
        
        // ä¸€æ‹¬é¸æŠãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆ
        function toggleRangeSelectMode() {
            rangeSelectMode = document.getElementById('rangeSelectMode').checked;
            rangeSelectStart = null;
        }
        
        // ç¯„å›²é¸æŠå‡¦ç†
        function handleRangeSelect(coordinateId) {
            if (!rangeSelectStart) {
                rangeSelectStart = coordinateId;
                if (selectedCoordinateIds.has(coordinateId)) {
                    selectedCoordinateIds.delete(coordinateId);
                } else {
                    selectedCoordinateIds.add(coordinateId);
                }
            } else {
                if (rangeSelectStart === coordinateId) {
                    if (selectedCoordinateIds.has(coordinateId)) {
                        selectedCoordinateIds.delete(coordinateId);
                    }
                    rangeSelectStart = null;
                } else {
                    const displayCoords = filteredCoordinates.length > 0 ? filteredCoordinates : savedCoordinates;
                    const startIndex = displayCoords.findIndex(c => c.id === rangeSelectStart);
                    const endIndex = displayCoords.findIndex(c => c.id === coordinateId);
                    
                    const minIndex = Math.min(startIndex, endIndex);
                    const maxIndex = Math.max(startIndex, endIndex);
                    
                    for (let i = minIndex; i <= maxIndex; i++) {
                        selectedCoordinateIds.add(displayCoords[i].id);
                    }
                    
                    rangeSelectStart = null;
                }
            }
            
            updateCoordinatesList();
            updateStats();
        }
        
        // åº§æ¨™é¸æŠãƒˆã‚°ãƒ«
        function toggleCoordinateSelection(id, checked) {
            if (checked) {
                selectedCoordinateIds.add(id);
            } else {
                selectedCoordinateIds.delete(id);
            }
            updateStats();
        }
        
        // ã™ã¹ã¦ã®åº§æ¨™é¸æŠãƒˆã‚°ãƒ«
        function toggleSelectAllCoordinates(checked) {
            const displayCoords = filteredCoordinates.length > 0 ? filteredCoordinates : savedCoordinates;
            if (checked) {
                displayCoords.forEach(c => selectedCoordinateIds.add(c.id));
            } else {
                displayCoords.forEach(c => selectedCoordinateIds.delete(c.id));
            }
            updateCoordinatesList();
            updateStats();
        }
        
        // é¸æŠæ¸ˆã¿åº§æ¨™ã‚’éè¡¨ç¤º
        function hideSelectedCoordinates() {
            if (selectedCoordinateIds.size === 0) {
                alert('åº§æ¨™ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            selectedCoordinateIds.forEach(id => hiddenCoordinateIds.add(id));
            updateCoordinatesList();
            drawMap();
        }
        
        // é¸æŠæ¸ˆã¿åº§æ¨™ã®ã¿è¡¨ç¤º
        function showSelectedCoordinatesOnly() {
            if (selectedCoordinateIds.size === 0) {
                alert('åº§æ¨™ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }

            // ã™ã¹ã¦ã®åº§æ¨™ã‚’éè¡¨ç¤ºã«ã™ã‚‹
            savedCoordinates.forEach(coord => {
                if (!selectedCoordinateIds.has(coord.id)) {
                    hiddenCoordinateIds.add(coord.id);
                }
            });

            // é¸æŠæ¸ˆã¿åº§æ¨™ã¯è¡¨ç¤ºã™ã‚‹
            selectedCoordinateIds.forEach(id => {
                hiddenCoordinateIds.delete(id);
            });

            updateCoordinatesList();
            drawMap();
        }

        // ã™ã¹ã¦ã®åº§æ¨™ã‚’è¡¨ç¤º
        function showAllCoordinates() {
            hiddenCoordinateIds.clear();
            updateCoordinatesList();
            drawMap();
        }
        
        // é¸æŠåº§æ¨™ã®å‰Šé™¤
        function deleteSelectedCoordinates() {
            if (selectedCoordinateIds.size === 0) {
                alert('åº§æ¨™ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }

            if (confirm(`é¸æŠã•ã‚ŒãŸ${selectedCoordinateIds.size}ä»¶ã®åº§æ¨™ã‚’å‰Šé™¤ã—ã¾ã™ã‹?`)) {
                // Firebaseã‹ã‚‰å‰Šé™¤
                selectedCoordinateIds.forEach(id => {
                    deleteCoordinateFromFirebase(id).catch(error => {
                        console.error('åº§æ¨™ã®å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                    });
                    duplicateCoordinateIds.delete(id);
                    hiddenCoordinateIds.delete(id);
                });

                savedCoordinates = savedCoordinates.filter(c => !selectedCoordinateIds.has(c.id));

                coordinateGroups.forEach(group => {
                    group.coordinateIds = group.coordinateIds.filter(id => !selectedCoordinateIds.has(id));
                });

                // ã‚°ãƒ«ãƒ¼ãƒ—ã‚’Firebaseã«ä¿å­˜
                saveAllGroupsToFirebase().catch(error => {
                    console.error('ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                });

                selectedCoordinateIds.clear();
                updateCoordinatesList();
                updateGroupsList();
                updateStats();
                drawMap();
            }
        }
        
        // åº§æ¨™ç·¨é›†
        function editCoordinate(id) {
            const coord = savedCoordinates.find(c => c.id === id);
            if (!coord) return;
            
            const newName = prompt('æ–°ã—ã„åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:', coord.name);
            if (newName) {
                coord.name = newName;
                updateCoordinatesList();
            }
        }
        
        // åº§æ¨™å‰Šé™¤
        function deleteCoordinate(id) {
            const coord = savedCoordinates.find(c => c.id === id);
            if (!coord) return;
            
            if (confirm(`${coord.name} ã‚’å‰Šé™¤ã—ã¾ã™ã‹?`)) {
                savedCoordinates = savedCoordinates.filter(c => c.id !== id);
                selectedCoordinateIds.delete(id);
                hiddenCoordinateIds.delete(id);
                duplicateCoordinateIds.delete(id);
                
                coordinateGroups.forEach(group => {
                    group.coordinateIds = group.coordinateIds.filter(cid => cid !== id);
                });
                
                updateCoordinatesList();
                updateGroupsList();
                updateStats();
                drawMap();
            }
        }
        
        // ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆ
        function createGroup() {
            const name = document.getElementById('groupName').value.trim();
            if (!name) {
                alert('ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }

            coordinateGroups.push({
                id: Date.now().toString(),
                name: name,
                coordinateIds: Array.from(selectedCoordinateIds),
                createdAt: new Date().toISOString()
            });

            // Firebaseã«ä¿å­˜
            saveAllGroupsToFirebase().catch(error => {
                console.error('ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
            });

            document.getElementById('groupName').value = '';
            selectedCoordinateIds.clear();

            updateCoordinatesList();
            updateGroupsList();
            updateStats();
        }
        
        // ä¿®æ­£8: ã‚°ãƒ«ãƒ¼ãƒ—ãƒªã‚¹ãƒˆæ›´æ–° - ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³å¼
        function updateGroupsList() {
            const container = document.getElementById('groupList');
            container.innerHTML = '';
            
            coordinateGroups.forEach(group => {
                const div = document.createElement('div');
                div.className = 'group-item' + (expandedGroupId === group.id ? ' expanded' : '');
                
                const headerDiv = document.createElement('div');
                headerDiv.className = 'group-header';
                headerDiv.onclick = () => toggleGroupExpansion(group.id);
                
                headerDiv.innerHTML = `
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <span class="group-expand-icon">â–¶</span>
                        <strong style="flex: 1;">${group.name}</strong>
                        <span style="color: #666; margin-right: 8px;">(${(group.coordinateIds || []).length}ä»¶)</span>
                    </div>
                    <div class="item-actions" onclick="event.stopPropagation();">
                        <button onclick="selectGroupCoordinates('${group.id}')">é¸æŠ</button>
                        <button onclick="addCoordinatesToGroup('${group.id}')" style="background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);">â•è¿½åŠ </button>
                        <button onclick="editGroup('${group.id}')">âœï¸</button>
                        <button onclick="deleteGroup('${group.id}')"
                                style="background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);">ğŸ—‘ï¸</button>
                    </div>
                `;
                
                div.appendChild(headerDiv);
                
                // ä¿®æ­£8: åº§æ¨™ãƒªã‚¹ãƒˆã®å±•é–‹ï¼ˆéšå±¤è¡¨ç¤ºï¼‰
                const coordsDiv = document.createElement('div');
                coordsDiv.className = 'group-coordinates';
                
                const groupCoords = savedCoordinates.filter(c => (group.coordinateIds || []).includes(c.id));
                groupCoords.forEach((coord, index) => {
                    const coordItem = document.createElement('div');
                    coordItem.className = 'group-coord-item';
                    const isLast = index === groupCoords.length - 1;
                    const prefix = isLast ? 'â””' : 'â”œ';
                    coordItem.textContent = `${prefix} ${coord.name}: @${coord.x} ${coord.y}`;
                    coordItem.onclick = () => jumpToCoordinate(coord.id);
                    coordsDiv.appendChild(coordItem);
                });
                
                div.appendChild(coordsDiv);
                container.appendChild(div);
            });
        }
        
        // ä¿®æ­£8: ã‚°ãƒ«ãƒ¼ãƒ—å±•é–‹ãƒˆã‚°ãƒ«
        function toggleGroupExpansion(groupId) {
            if (expandedGroupId === groupId) {
                // åŒã˜ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ã‚¯ãƒªãƒƒã‚¯: é–‰ã˜ã‚‹
                expandedGroupId = null;
                groupFilterActive = false;
            } else {
                // åˆ¥ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ã‚¯ãƒªãƒƒã‚¯: é–‹ã
                expandedGroupId = groupId;
                groupFilterActive = true;
            }
            
            updateGroupsList();
            updateCoordinatesList();
        }
        
        // ã‚°ãƒ«ãƒ¼ãƒ—ã«åº§æ¨™ã‚’è¿½åŠ 
        function addCoordinatesToGroup(groupId) {
            const group = coordinateGroups.find(g => g.id === groupId);
            if (!group) return;
            
            if (selectedCoordinateIds.size === 0) {
                alert('åº§æ¨™ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            let addedCount = 0;
            let skippedCount = 0;
            
            selectedCoordinateIds.forEach(id => {
                if (!group.coordinateIds.includes(id)) {
                    group.coordinateIds.push(id);
                    addedCount++;
                } else {
                    skippedCount++;
                }
            });
            
            updateGroupsList();
            updateStats();
            
            alert(`${addedCount}ä»¶ã®åº§æ¨™ã‚’ã€Œ${group.name}ã€ã«è¿½åŠ ã—ã¾ã—ãŸã€‚\n(æ—¢ã«å«ã¾ã‚Œã¦ã„ãŸåº§æ¨™:${skippedCount}ä»¶)`);
        }
        
        // ã‚°ãƒ«ãƒ¼ãƒ—ã®åº§æ¨™ã‚’é¸æŠ
        function selectGroupCoordinates(groupId) {
            const group = coordinateGroups.find(g => g.id === groupId);
            if (!group) return;
            
            selectedCoordinateIds.clear();
            group.coordinateIds.forEach(id => {
                if (savedCoordinates.find(c => c.id === id)) {
                    selectedCoordinateIds.add(id);
                }
            });
            
            updateCoordinatesList();
            updateStats();
        }
        
        // ã‚°ãƒ«ãƒ¼ãƒ—ç·¨é›†
        function editGroup(groupId) {
            const group = coordinateGroups.find(g => g.id === groupId);
            if (!group) return;
            
            const newName = prompt('æ–°ã—ã„ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:', group.name);
            if (newName) {
                group.name = newName;
                updateGroupsList();
            }
        }
        
        // ã‚°ãƒ«ãƒ¼ãƒ—å‰Šé™¤
        function deleteGroup(groupId) {
            if (groupId === 'default') {
                alert('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚°ãƒ«ãƒ¼ãƒ—ã¯å‰Šé™¤ã§ãã¾ã›ã‚“');
                return;
            }

            if (confirm('ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å‰Šé™¤ã—ã¾ã™ã‹?(åº§æ¨™è‡ªä½“ã¯å‰Šé™¤ã•ã‚Œã¾ã›ã‚“)')) {
                coordinateGroups = coordinateGroups.filter(g => g.id !== groupId);
                if (expandedGroupId === groupId) {
                    expandedGroupId = null;
                    groupFilterActive = false;
                }

                // Firebaseã‹ã‚‰å‰Šé™¤
                deleteGroupFromFirebase(groupId).catch(error => {
                    console.error('ã‚°ãƒ«ãƒ¼ãƒ—ã®å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                });

                updateGroupsList();
                updateCoordinatesList();
                updateStats();
            }
        }
        
        // éšœå®³ç‰©ã‚¿ã‚¤ãƒ—é¸æŠ
        function selectObstacleType(type) {
            if (currentMode !== 'input' && currentMode !== 'delete') {
                alert('å…¥åŠ›ãƒ¢ãƒ¼ãƒ‰ã¾ãŸã¯å‰Šé™¤ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            selectedObstacleType = selectedObstacleType === type ? null : type;
            
            document.querySelectorAll('.obstacle-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            if (selectedObstacleType) {
                const btnId = type === 'rock' ? 'obstacleRock' : `obstacle_${type}`;
                const btn = document.getElementById(btnId);
                if (btn) btn.classList.add('selected');
            }
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ãƒ•ã‚©ãƒ¼ãƒ è¡¨ç¤º
        function showCustomObstacleForm() {
            document.getElementById('customObstacleFormContainer').style.display = 'block';
            isCreatingCustomObstacle = false;
            customObstacleInProgress = null;
            document.getElementById('tempShapeMessage').style.display = 'none';
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ãƒ•ã‚©ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        function cancelCustomObstacleForm() {
            document.getElementById('customObstacleFormContainer').style.display = 'none';
            document.getElementById('customObstacleName').value = '';
            isCreatingCustomObstacle = false;
            customObstacleInProgress = null;
            tempSelection.clear();
            document.getElementById('tempShapeMessage').style.display = 'none';
            drawMap();
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ä½œæˆ
        function createCustomObstacle() {
            const name = document.getElementById('customObstacleName').value.trim();
            const placementType = document.getElementById('customObstaclePlacementType').value;
            const color = getSelectedColor();
            
            if (!name) {
                alert('éšœå®³ç‰©åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            if (placementType === 'tap') {
                if (!isCreatingCustomObstacle) {
                    isCreatingCustomObstacle = true;
                    customObstacleInProgress = {
                        name: name,
                        color: color,
                        placementType: placementType
                    };
                    
                    document.getElementById('tempShapeMessage').style.display = 'block';
                    changeMode('input');
                    selectedObstacleType = 'temp_custom';
                    return;
                } else {
                    if (tempSelection.size === 0) {
                        alert('éšœå®³ç‰©ã®å½¢çŠ¶ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                        return;
                    }
                    
                    const customId = `custom_${Date.now()}`;
                    
                    const firstKey = Array.from(tempSelection)[0];
                    const [fx, fy] = firstKey.split(',').map(Number);
                    const shape = Array.from(tempSelection).map(key => {
                        const [x, y] = key.split(',').map(Number);
                        return `${x - fx},${y - fy}`;
                    });
                    
                    customObstacles.push({
                        id: customId,
                        name: name,
                        color: customObstacleInProgress.color,
                        shape: shape
                    });
                    
                    tempSelection.clear();
                    
                    updateCustomObstacleButtons();
                    cancelCustomObstacleForm();
                    updateStats();
                    drawMap();
                    
                    alert(`ç”Ÿæˆã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ å½¢çŠ¶ã‚’ã€åç§°ã€Œ${name}ã€ã¨ã—ã¦ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä¿ç®¡ã—ã€ãƒãƒƒãƒ—ä¸Šã«ç”Ÿæˆã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã¯ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚\néšœå®³ç‰©ç®¡ç†æ¬„ã‹ã‚‰ä½¿ç”¨å¯èƒ½ã§ã™ã€‚`);
                    return;
                }
            }
            
            const customId = `custom_${Date.now()}`;
            customObstacles.push({
                id: customId,
                name: name,
                color: color,
                shape: ['0,0']
            });
            
            updateCustomObstacleButtons();
            cancelCustomObstacleForm();
            
            alert(`ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ã€Œ${name}ã€ã‚’ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã¨ã—ã¦ä½œæˆã—ã¾ã—ãŸã€‚\néšœå®³ç‰©ç®¡ç†æ¬„ã‹ã‚‰ä½¿ç”¨å¯èƒ½ã§ã™ã€‚`);
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ãƒœã‚¿ãƒ³ã‚’æ›´æ–°
        function updateCustomObstacleButtons() {
            const container = document.getElementById('customObstacleButtons');
            container.innerHTML = '';
            
            customObstacles.forEach(obstacle => {
                const div = document.createElement('div');
                div.className = 'custom-obstacle-display';
                
                const displayColor = obstacle.color;
                
                div.innerHTML = `
                    <div class="color-swatch" style="background-color: ${displayColor}"></div>
                    <button onclick="selectObstacleType('${obstacle.id}')" class="obstacle-btn" id="obstacle_${obstacle.id}" style="flex: 1;">
                        ${obstacle.name}
                    </button>
                `;
                container.appendChild(div);
            });
        }
        
        // éšœå®³ç‰©ã®ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
        function groupObstacles() {
            const typeGroups = {};
            
            obstacles.forEach(obstacle => {
                if (!typeGroups[obstacle.type]) {
                    typeGroups[obstacle.type] = [];
                }
                obstacle.cells.forEach(cell => {
                    typeGroups[obstacle.type].push(cell);
                });
            });
            
            obstacles = [];
            
            for (const [type, cells] of Object.entries(typeGroups)) {
                const visited = new Set();
                const cellSet = new Set(cells);
                
                cells.forEach(cell => {
                    if (visited.has(cell)) return;
                    
                    const component = [];
                    const queue = [cell];
                    
                    while (queue.length > 0) {
                        const current = queue.shift();
                        if (visited.has(current)) continue;
                        
                        visited.add(current);
                        component.push(current);
                        
                        const [x, y] = current.split(',').map(Number);
                        const neighbors = [
                            `${x+1},${y}`,
                            `${x-1},${y}`,
                            `${x},${y+1}`,
                            `${x},${y-1}`
                        ];
                        
                        neighbors.forEach(neighbor => {
                            if (cellSet.has(neighbor) && !visited.has(neighbor)) {
                                queue.push(neighbor);
                            }
                        });
                    }
                    
                    if (component.length > 0) {
                        obstacles.push({
                            id: Date.now().toString() + '-' + Math.floor(Math.random() * 1000000),
                            type: type,
                            cells: component
                        });
                    }
                });
            }
        }
        
        // éšœå®³ç‰©ãƒªã‚¹ãƒˆæ›´æ–°
        function updateObstaclesList() {
            const container = document.getElementById('obstacleList');
            container.innerHTML = '';
            
            if (obstacles.length > 0) {
                const selectAllDiv = document.createElement('div');
                selectAllDiv.style.cssText = 'background: #e3f2fd; padding: 8px; margin-bottom: 8px; border-radius: 4px;';
                selectAllDiv.innerHTML = `
                    <label style="cursor: pointer; font-weight: bold;">
                        <input type="checkbox" id="selectAllObstacles" onchange="toggleSelectAllObstacles(this.checked)">
                        ã™ã¹ã¦é¸æŠ
                    </label>
                `;
                container.appendChild(selectAllDiv);
            }
            
            obstacles.forEach((obstacle, index) => {
                const div = document.createElement('div');
                div.className = 'obstacle-item';
                
                let obstacleName = obstacleNames[obstacle.type] || obstacle.type;
                const customObstacle = customObstacles.find(o => o.id === obstacle.type);
                if (customObstacle) {
                    obstacleName = customObstacle.name;
                }
                
                div.innerHTML = `
                    <label style="display: flex; align-items: center; flex: 1; cursor: pointer;">
                        <input type="checkbox" ${selectedObstacleIds.has(obstacle.id) ? 'checked' : ''} 
                               onchange="toggleObstacleSelection(${obstacle.id}, this.checked)">
                        <span>${obstacleName} #${index + 1} (${obstacle.cells.length}ãƒã‚¹)</span>
                    </label>
                    <div class="item-actions">
                        <button onclick="deleteObstacleItem(${obstacle.id})" 
                                style="background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);">ğŸ—‘ï¸</button>
                    </div>
                `;
                container.appendChild(div);
            });
        }
        
        // ã™ã¹ã¦ã®éšœå®³ç‰©ã‚’é¸æŠ/è§£é™¤
        function toggleSelectAllObstacles(checked) {
            if (checked) {
                obstacles.forEach(o => selectedObstacleIds.add(o.id));
            } else {
                selectedObstacleIds.clear();
            }
            updateObstaclesList();
        }
        
        // éšœå®³ç‰©ã®é¸æŠãƒˆã‚°ãƒ«
        function toggleObstacleSelection(id, checked) {
            if (checked) {
                selectedObstacleIds.add(id);
            } else {
                selectedObstacleIds.delete(id);
            }
        }
        
        // éšœå®³ç‰©ã‚¢ã‚¤ãƒ†ãƒ ã®å‰Šé™¤
        function deleteObstacleItem(id) {
            if (confirm('ã“ã®éšœå®³ç‰©ã‚’å‰Šé™¤ã—ã¾ã™ã‹?')) {
                obstacles = obstacles.filter(o => o.id !== id);
                selectedObstacleIds.delete(id);
                updateObstaclesList();
                updateStats();
                drawMap();
            }
        }
        
        // é¸æŠã•ã‚ŒãŸéšœå®³ç‰©ã®å‰Šé™¤
        function deleteSelectedObstacles() {
            if (selectedObstacleIds.size === 0) {
                alert('éšœå®³ç‰©ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }

            if (confirm(`é¸æŠã•ã‚ŒãŸ${selectedObstacleIds.size}ä»¶ã®éšœå®³ç‰©ã‚’å‰Šé™¤ã—ã¾ã™ã‹?`)) {
                obstacles = obstacles.filter(o => !selectedObstacleIds.has(o.id));
                selectedObstacleIds.clear();

                // Firebaseã«ä¿å­˜
                saveObstaclesToFirebase().catch(error => {
                    console.error('éšœå®³ç‰©ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                });

                updateObstaclesList();
                updateStats();
                drawMap();
            }
        }
        
        // ã‚ºãƒ¼ãƒ 
        function zoomIn() {
            scale = Math.min(scale * 1.5, 20);
            drawMap();
        }
        
        function zoomOut() {
            scale = Math.max(scale / 1.5, 0.5);
            drawMap();
        }
        
        // ãƒ‡ãƒ¼ã‚¿å‡ºåŠ›
        function exportData() {
            // é¸æŠåº§æ¨™ã®æ•°ã‚’ç¢ºèª
            const selectedCount = selectedCoordinateIds.size;

            if (selectedCount === 0) {
                // é¸æŠåº§æ¨™ãŒãªã„å ´åˆ
                const exportAll = confirm('é¸æŠæ¸ˆã¿åº§æ¨™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚å…¨åº§æ¨™ã‚’å‡ºåŠ›ã—ã¾ã™ã‹ï¼Ÿ');
                if (!exportAll) {
                    return; // å‡ºåŠ›ã—ãªã„
                }
                // å…¨åº§æ¨™ã‚’å‡ºåŠ›
                exportAllData();
            } else {
                // é¸æŠåº§æ¨™ãŒã‚ã‚‹å ´åˆ
                const confirmExport = confirm(`é¸æŠä¸­ã®${selectedCount}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‡ºåŠ›ã—ã¾ã™ã‹ï¼Ÿ`);
                if (!confirmExport) {
                    return; // å‡ºåŠ›ã—ãªã„
                }
                // é¸æŠåº§æ¨™ã®ã¿ã‚’å‡ºåŠ›
                exportSelectedData();
            }
        }

        // é¸æŠåº§æ¨™ã®ã¿ã‚’å‡ºåŠ›
        function exportSelectedData() {
            const selectedCoords = savedCoordinates.filter(c => selectedCoordinateIds.has(c.id));

            let text = '=== é¸æŠæ¸ˆã¿åº§æ¨™ãƒ‡ãƒ¼ã‚¿ ===\n';
            selectedCoords.forEach(coord => {
                text += `${coord.name}@${coord.x} ${coord.y}\n`;
            });

            text += '\n=== é¸æŠåº§æ¨™ã‚’å«ã‚€ã‚°ãƒ«ãƒ¼ãƒ— ===\n';
            coordinateGroups.forEach(group => {
                const groupSelectedCoords = selectedCoords.filter(c => group.coordinateIds.includes(c.id));
                if (groupSelectedCoords.length > 0) {
                    text += `\n[${group.name}]\n`;
                    groupSelectedCoords.forEach(coord => {
                        text += `${coord.name}@${coord.x} ${coord.y}\n`;
                    });
                }
            });

            downloadTextFile(text, 'selected_coordinates.txt');
        }

        // å…¨åº§æ¨™ã‚’å‡ºåŠ›
        function exportAllData() {
            let text = '=== åº§æ¨™ãƒ‡ãƒ¼ã‚¿ ===\n';
            savedCoordinates.forEach(coord => {
                text += `${coord.name}@${coord.x} ${coord.y}\n`;
            });

            text += '\n=== ã‚°ãƒ«ãƒ¼ãƒ— ===\n';
            coordinateGroups.forEach(group => {
                const coords = savedCoordinates.filter(c => group.coordinateIds.includes(c.id));
                text += `\n[${group.name}]\n`;
                coords.forEach(coord => {
                    text += `${coord.name}@${coord.x} ${coord.y}\n`;
                });
            });

            text += '\n=== éšœå®³ç‰© ===\n';
            obstacles.forEach((obstacle, index) => {
                let obstacleName = obstacleNames[obstacle.type] || obstacle.type;
                const customObstacle = customObstacles.find(o => o.id === obstacle.type);
                if (customObstacle) {
                    obstacleName = customObstacle.name;
                }
                text += `${obstacleName} #${index + 1}: ${obstacle.cells.length}ãƒã‚¹\n`;
            });

            downloadTextFile(text, 'map_data.txt');
        }
        
        // ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
        function downloadTextFile(text, filename) {
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // ä¿®æ­£2: å…¨ç”»é¢è¡¨ç¤ºã®åˆ‡ã‚Šæ›¿ãˆ - ãƒªã‚µã‚¤ã‚ºå‡¦ç†ã®æ”¹å–„
        function toggleFullscreen() {
            const section = document.querySelector('.map-section');
            const btn = document.getElementById('fullscreenBtn');

            if (!section) {
                alert('ãƒãƒƒãƒ—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return;
            }

            if (!document.fullscreenElement) {
                section.requestFullscreen().then(() => {
                    section.classList.add('fullscreen-container');
                    btn.textContent = 'âœ• å…¨ç”»é¢è§£é™¤';

                    // ä¿®æ­£2: å…¨ç”»é¢è¡¨ç¤ºæ™‚ã®ãƒªã‚µã‚¤ã‚ºã‚’å¼·åˆ¶å®Ÿè¡Œ
                    setTimeout(() => {
                        resizeCanvas();
                        drawMap();
                    }, 100);
                }).catch(err => {
                    alert('å…¨ç”»é¢è¡¨ç¤ºã«å¤±æ•—ã—ã¾ã—ãŸ: ' + err.message);
                });
            } else {
                document.exitFullscreen().then(() => {
                    section.classList.remove('fullscreen-container');
                    btn.textContent = 'ğŸ–¼ï¸ å…¨ç”»é¢è¡¨ç¤º';

                    // ä¿®æ­£2: å…¨ç”»é¢è§£é™¤æ™‚ã®ãƒªã‚µã‚¤ã‚ºã‚’å¼·åˆ¶å®Ÿè¡Œ
                    setTimeout(() => {
                        resizeCanvas();
                        drawMap();
                    }, 100);
                });
            }
        }

        // å…¨ç”»é¢è¡¨ç¤ºã®å¤‰æ›´ã‚’ç›£è¦–
        document.addEventListener('fullscreenchange', () => {
            const section = document.querySelector('.map-section');
            const btn = document.getElementById('fullscreenBtn');
            if (!document.fullscreenElement && section) {
                section.classList.remove('fullscreen-container');
                btn.textContent = 'ğŸ–¼ï¸ å…¨ç”»é¢è¡¨ç¤º';
                resizeCanvas();
            }
        });
        
        // ä¿®æ­£4: çµ±è¨ˆã®æ›´æ–° - å±…ä½ç¯„å›²å æœ‰ç‡ã®è¿½åŠ 
        function updateStats() {
            document.getElementById('coordCount').textContent = savedCoordinates.length;
            document.getElementById('obstacleCount').textContent = obstacles.length;
            document.getElementById('groupCount').textContent = coordinateGroups.length;
            document.getElementById('selectedCount').textContent = selectedCoordinateIds.size;
            
            // ä¿®æ­£4: å±…ä½ç¯„å›²å æœ‰ç‡ã®è¨ˆç®—
            const primeZoneTotalCells = (primeZone.maxX - primeZone.minX + 1) * (primeZone.maxY - primeZone.minY + 1);
            
            // éšœå®³ç‰©ã®ãƒã‚¹æ•°ã‚’è¨ˆç®—(ä¸€ç´šåœ°å¸¯å†…ã®ã¿)
            let obstacleCells = new Set();
            obstacles.forEach(obstacle => {
                obstacle.cells.forEach(cell => {
                    const [x, y] = cell.split(',').map(Number);
                    if (x >= primeZone.minX && x <= primeZone.maxX && 
                        y >= primeZone.minY && y <= primeZone.maxY) {
                        obstacleCells.add(cell);
                    }
                });
            });
            
            // åŸã®ãƒã‚¹æ•°ã‚’è¨ˆç®—(ä¸€ç´šåœ°å¸¯å†…ã®ã¿)
            let castleCells = new Set();
            castles.forEach(castle => {
                for (let dx = -8; dx <= 8; dx++) {
                    for (let dy = -8; dy <= 8; dy++) {
                        const x = castle.x + dx;
                        const y = castle.y + dy;
                        if (x >= primeZone.minX && x <= primeZone.maxX && 
                            y >= primeZone.minY && y <= primeZone.maxY) {
                            castleCells.add(`${x},${y}`);
                        }
                    }
                }
            });
            
            // åˆ©ç”¨å¯èƒ½ãƒã‚¹æ•° = ä¸€ç´šåœ°å¸¯å…¨ä½“ - éšœå®³ç‰© - åŸ
            const availableCells = primeZoneTotalCells - obstacleCells.size - castleCells.size;
            
            // å±…ä½ç¯„å›²ã®ãƒã‚¹æ•°ã‚’è¨ˆç®—(ä¸€ç´šåœ°å¸¯å†…ã€ã‹ã¤è¡¨ç¤ºä¸­ã®åº§æ¨™ã®ã¿)
            let residenceCells = new Set();
            savedCoordinates.forEach(coord => {
                if (hiddenCoordinateIds.has(coord.id)) return;
                
                for (let dx = -10; dx <= 10; dx++) {
                    for (let dy = -10; dy <= 10; dy++) {
                        const x = coord.x + dx;
                        const y = coord.y + dy;
                        if (x >= primeZone.minX && x <= primeZone.maxX && 
                            y >= primeZone.minY && y <= primeZone.maxY) {
                            residenceCells.add(`${x},${y}`);
                        }
                    }
                }
            });
            
            // å æœ‰ç‡ã‚’è¨ˆç®—
            const occupancyRate = availableCells > 0 ? (residenceCells.size / availableCells * 100).toFixed(1) : 0;
            document.getElementById('occupancyRate').textContent = `${occupancyRate}%`;
        }
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«åˆæœŸåŒ–
        window.addEventListener('load', init);
    </script>
</body>
</html>
