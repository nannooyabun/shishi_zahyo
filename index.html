<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>ã‚²ãƒ¼ãƒ åº§æ¨™ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ </title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
            overscroll-behavior: none;
        }
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            text-align: center;
        }
        .header h1 {
            font-size: 28px;
            margin-bottom: 8px;
        }
        @media (max-width: 768px) {
            .header h1 {
                font-size: 20px;
            }
            .header p {
                font-size: 13px;
            }
        }
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
        }
        .top-panel {
            width: 100%;
        }
        .bottom-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 768px) {
            .main-content {
                padding: 10px;
            }
            .bottom-panel {
                grid-template-columns: 1fr;
            }
        }
        @media (max-aspect-ratio: 1/1) and (min-width: 769px) {
            .bottom-panel {
                grid-template-columns: 1fr;
            }
        }
        .section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        @media (max-width: 768px) {
            .section {
                padding: 15px;
                margin-bottom: 15px;
            }
        }
        .section h2 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #333;
        }
        /* å…¨ç”»é¢è¡¨ç¤ºã‚¹ã‚¿ã‚¤ãƒ« */
        .fullscreen-container {
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw !important;
            max-height: 100vh !important;
            overflow: hidden;
            background: white;
            margin: 0;
            padding: 0;
        }
        .fullscreen-container .section {
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            margin: 0;
            padding: 0;
            border-radius: 0;
        }
        .fullscreen-container canvas {
            flex: 1;
            width: 100% !important;
            height: 100% !important;
            max-width: 100vw !important;
            max-height: 100vh !important;
        }
        .fullscreen-container .map-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .fullscreen-container .mode-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .fullscreen-container .grid-display {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        /* ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ï¼ˆé€šå¸¸è¡¨ç¤ºæ™‚ï¼‰ */
        .map-section {
            position: relative;
        }
        .floating-controls .map-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .floating-controls .mode-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .floating-controls .grid-display {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        textarea {
            width: 100%;
            min-height: 200px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-family: monospace;
            font-size: 13px;
            resize: vertical;
        }
        @media (max-width: 768px) {
            textarea {
                font-size: 16px;
                min-height: 150px;
            }
        }
        input[type="text"],
        input[type="number"],
        input[type="date"] {
            font-size: 13px;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 4px;
        }
        @media (max-width: 768px) {
            input[type="text"],
            input[type="number"],
            input[type="date"] {
                font-size: 16px;
                min-height: 44px;
            }
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
            margin-top: 8px;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }
        @media (max-width: 768px) {
            button {
                padding: 12px 20px;
                font-size: 16px;
                min-height: 44px;
            }
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        button:active {
            transform: translateY(0);
        }
        button.secondary {
            background: linear-gradient(135deg, #78909c 0%, #546e7a 100%);
        }
        .mode-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        .mode-btn {
            flex: 1;
            margin: 0;
        }
        .mode-btn.active {
            background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
        }
        #mapCanvas {
            width: 100%;
            height: 600px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: crosshair;
            background: #f5f5f5;
            touch-action: none;
        }
        @media (max-width: 768px) {
            #mapCanvas {
                height: 400px;
            }
        }
        @media (min-width: 769px) and (max-aspect-ratio: 1/1) {
            #mapCanvas {
                height: 500px;
            }
        }
        .map-controls {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            flex-wrap: wrap;
        }
        .map-controls button {
            flex: 1;
            min-width: 120px;
            margin: 0;
        }
        @media (max-width: 768px) {
            .map-controls {
                gap: 6px;
            }
            .map-controls button {
                min-width: 100px;
                font-size: 13px;
                padding: 10px 12px;
            }
        }
        .obstacle-btn {
            margin: 4px 0;
        }
        .obstacle-btn.selected {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 12px;
        }
        .stat-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }
        .coordinate-item, .obstacle-item, .group-item {
            background: white;
            padding: 10px;
            margin: 6px 0;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }
        @media (max-width: 768px) {
            .coordinate-item, .obstacle-item, .group-item {
                padding: 12px;
                font-size: 14px;
                min-height: 50px;
            }
        }
        .coordinate-item input[type="checkbox"],
        .obstacle-item input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        @media (max-width: 768px) {
            .coordinate-item input[type="checkbox"],
            .obstacle-item input[type="checkbox"] {
                width: 24px;
                height: 24px;
                margin-right: 12px;
            }
        }
        .item-actions {
            display: flex;
            gap: 6px;
        }
        .item-actions button {
            width: auto;
            padding: 6px 12px;
            margin: 0;
            font-size: 12px;
            min-width: auto;
        }
        @media (max-width: 768px) {
            .item-actions button {
                padding: 8px 14px;
                font-size: 14px;
            }
        }
        .grid-display {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        .grid-display label {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .grid-display input[type="radio"] {
            margin-right: 6px;
        }
        .grid-display label:has(input:checked) {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        .toggle-switch input[type="checkbox"] {
            width: 50px;
            height: 26px;
            appearance: none;
            background: #ccc;
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        .toggle-switch input[type="checkbox"]:checked {
            background: #4caf50;
        }
        .toggle-switch input[type="checkbox"]::before {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }
        .toggle-switch input[type="checkbox"]:checked::before {
            left: 26px;
        }
        .custom-obstacle-form {
            background: #fff;
            padding: 15px;
            border-radius: 6px;
            margin-top: 10px;
        }
        .custom-obstacle-form input,
        .custom-obstacle-form select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 2px solid #e0e0e0;
            border-radius: 4px;
        }
        .color-picker {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .color-option {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
        }
        .color-option.selected {
            border-color: #333;
            transform: scale(1.1);
        }
        .custom-obstacle-display {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 4px;
            margin: 4px 0;
        }
        .custom-obstacle-display .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid #999;
        }
        .parse-result-item {
            background: white;
            padding: 10px;
            margin: 6px 0;
            border-radius: 6px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .parse-result-item input {
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .parse-result-item .name-input {
            flex: 2;
        }
        .parse-result-item .coord-input {
            flex: 1;
            width: 60px;
        }
        .filter-controls {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .filter-controls input,
        .filter-controls select {
            flex: 1;
            min-width: 120px;
        }
        .temp-message {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-weight: bold;
            text-align: center;
            color: #856404;
        }
        .coordinate-name-link {
            cursor: pointer;
            color: #667eea;
            text-decoration: none;
        }
        .coordinate-name-link:hover {
            text-decoration: underline;
        }
        .adjust-mode-panel {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 12px;
        }
        .adjust-mode-panel input {
            width: 100%;
            padding: 8px;
            margin: 8px 0;
            border: 2px solid #2196f3;
            border-radius: 4px;
        }
        /* ã‚°ãƒ«ãƒ¼ãƒ—ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³ã‚¹ã‚¿ã‚¤ãƒ« */
        .group-item {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .group-item:hover {
            background-color: #f5f5f5;
        }
        .group-item.expanded {
            background-color: #e3f2fd;
        }
        .group-header {
            display: flex;
            align-items: center;
            width: 100%;
        }
        .group-expand-icon {
            margin-right: 8px;
            font-size: 16px;
            transition: transform 0.2s;
        }
        .group-item.expanded .group-expand-icon {
            transform: rotate(90deg);
        }
        .group-coordinates {
            display: none;
            margin-top: 10px;
            padding-left: 24px;
            border-left: 3px solid #667eea;
        }
        .group-item.expanded .group-coordinates {
            display: block;
        }
        .group-coord-item {
            background: #f8f9fa;
            padding: 8px;
            margin: 4px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .group-coord-item:hover {
            background-color: #e9ecef;
        }
        .no-results-message {
            text-align: center;
            padding: 20px;
            color: #999;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ—ºï¸ ã‚²ãƒ¼ãƒ åº§æ¨™ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ </h1>
            <p>ä¸€ç´šåœ°å¸¯ X200-439 Y760-999 ã®åº§æ¨™ç®¡ç†</p>
        </div>
        
        <div class="main-content">
            <!-- ãƒˆãƒƒãƒ—ãƒ‘ãƒãƒ«:ãƒãƒƒãƒ—è¡¨ç¤º -->
            <div class="top-panel">
                <!-- ãƒãƒƒãƒ—è¡¨ç¤º -->
                <div class="section map-section floating-controls">
                    <h2>ğŸ—ºï¸ ãƒãƒƒãƒ—è¡¨ç¤º</h2>
                    
                    <!-- ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºåˆ‡æ›¿ -->
                    <div class="grid-display">
                        <label>
                            <input type="radio" name="gridType" value="square" checked onchange="changeGridType('square')">
                            â¬œ æ­£æ–¹å½¢
                        </label>
                        <label>
                            <input type="radio" name="gridType" value="diamond" onchange="changeGridType('diamond')">
                            ğŸ”· ã²ã—å½¢
                        </label>
                    </div>
                    
                    <!-- è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ -->
                    <div class="mode-toggle">
                        <button class="mode-btn active" onclick="changeMode('view')">ğŸ‘€ é–²è¦§</button>
                        <button class="mode-btn" onclick="changeMode('input')">âœï¸ å…¥åŠ›</button>
                        <button class="mode-btn" onclick="changeMode('adjust')">ğŸ”§ åº§æ¨™èª¿æ•´</button>
                        <button class="mode-btn" onclick="changeMode('delete')">ğŸ—‘ï¸ å‰Šé™¤</button>
                    </div>
                    
                    <!-- åº§æ¨™èª¿æ•´ãƒ¢ãƒ¼ãƒ‰ãƒ‘ãƒãƒ« -->
                    <div id="adjustModePanel" class="adjust-mode-panel" style="display: none;">
                        <strong>åº§æ¨™èª¿æ•´ãƒ¢ãƒ¼ãƒ‰</strong>
                        <input type="text" id="adjustGroupName" placeholder="ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›">
                        <button onclick="saveAdjustedGroup()">ğŸ’¾ èª¿æ•´åº§æ¨™ã‚’ä¿å­˜</button>
                        <button onclick="cancelAdjustMode()" class="secondary">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                    </div>
                    
                    <canvas id="mapCanvas"></canvas>
                    
                    <div class="map-controls">
                        <button onclick="zoomIn()">ğŸ” æ‹¡å¤§</button>
                        <button onclick="zoomOut()">ğŸ” ç¸®å°</button>
                        <button onclick="jumpToPrimeZone()" style="background: linear-gradient(135deg, #ffd700 0%, #ffb700 100%);">ğŸ  ä¸€ç´šåœ°å¸¯ã¸</button>
                        <button onclick="toggleFullscreen()" id="fullscreenBtn">ğŸ–¼ï¸ å…¨ç”»é¢è¡¨ç¤º</button>
                        <button onclick="exportData()" style="background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);">ğŸ’¾ ãƒ‡ãƒ¼ã‚¿å‡ºåŠ›</button>
                    </div>
                </div>
                
                <!-- çµ±è¨ˆ -->
                <div class="section">
                    <h2>ğŸ“Š çµ±è¨ˆæƒ…å ±</h2>
                    <div class="stats">
                        <div class="stat-item">
                            <div class="stat-value" id="coordCount">0</div>
                            <div class="stat-label">åº§æ¨™æ•°</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="obstacleCount">0</div>
                            <div class="stat-label">éšœå®³ç‰©</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="groupCount">0</div>
                            <div class="stat-label">ã‚°ãƒ«ãƒ¼ãƒ—</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="selectedCount">0</div>
                            <div class="stat-label">é¸æŠä¸­</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="occupancyRate">0%</div>
                            <div class="stat-label">å±…ä½ç¯„å›²å æœ‰ç‡</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ãƒœãƒˆãƒ ãƒ‘ãƒãƒ«:2ã‚«ãƒ©ãƒ ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ -->
            <div class="bottom-panel">
                <!-- å·¦ã‚«ãƒ©ãƒ  -->
                <div class="left-column">
                    <!-- åº§æ¨™å…¥åŠ› -->
                    <div class="section">
                        <h2>ğŸ“ åº§æ¨™å…¥åŠ›</h2>
                        <label>åŒºåˆ‡ã‚Šæ–‡å­—(ä»»æ„ãƒ»ç©ºæ¬„å¯):</label>
                        <input type="text" id="customDelimiter" placeholder="ä¾‹: | ã¾ãŸã¯ : ãªã©" style="width: 100%; margin-bottom: 8px;">
                        <textarea id="coordInput" placeholder="åº§æ¨™ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„&#10;ä¾‹:&#10;åŸA @320 850&#10;åŸB @350 870&#10;&#10;ã¾ãŸã¯é€£ç¶šå…¥åŠ›:&#10;äº¬ç”°æ¥“èŠ±: @385 767ã€ç¶¾ç€¬: è©²å½“ãªã—ç¶¾ç€¬ã¯ã‚‹ã‹1@354 875"></textarea>
                        <button onclick="parseCoordinates()">ğŸ“¥ åº§æ¨™ã‚’è§£æ</button>
                    </div>
                    
                    <!-- è§£æçµæœ -->
                    <div class="section" id="parseResultSection" style="display: none;">
                        <h2>âœ… è§£æçµæœ(ä¿®æ­£å¯èƒ½)</h2>
                        <div id="parseResult" style="max-height: 300px; overflow-y: auto;"></div>
                        <button onclick="saveCoordinates()">ğŸ’¾ åº§æ¨™ã‚’ä¿å­˜</button>
                        <button onclick="clearParseResult()" class="secondary">ğŸ—‘ï¸ è§£æçµæœã‚’ã‚¯ãƒªã‚¢</button>
                    </div>
                    
                    <!-- ã‚°ãƒ«ãƒ¼ãƒ—ç®¡ç† -->
                    <div class="section">
                        <h2>ğŸ“¦ ã‚°ãƒ«ãƒ¼ãƒ—ç®¡ç†</h2>
                        <input type="text" id="groupName" placeholder="ã‚°ãƒ«ãƒ¼ãƒ—å" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <button onclick="createGroup()">â• ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆ</button>
                        <div id="groupList" style="max-height: 400px; overflow-y: auto; margin-top: 12px;"></div>
                    </div>
                    
                    <!-- éšœå®³ç‰©ç®¡ç† -->
                    <div class="section">
                        <h2>ğŸš§ éšœå®³ç‰©ç®¡ç†</h2>
                        <div style="margin-bottom: 12px;">
                            <button onclick="selectObstacleType('rock')" class="obstacle-btn" id="obstacleRock">ğŸª¨ å²©</button>
                            <div id="customObstacleButtons"></div>
                            <button onclick="showCustomObstacleForm()" style="background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%); margin-top: 8px;">â• ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ã‚’ä½œæˆ</button>
                        </div>
                        
                        <div id="customObstacleFormContainer" style="display: none;">
                            <div class="custom-obstacle-form">
                                <h3>ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ä½œæˆ</h3>
                                <input type="text" id="customObstacleName" placeholder="éšœå®³ç‰©å(ä¾‹:é™£å±‹)">
                                <div>
                                    <label>é…ç½®æ–¹æ³•:</label>
                                    <select id="customObstaclePlacementType">
                                        <option value="tap">ã‚¿ãƒƒãƒ—é…ç½®</option>
                                        <option value="single">å˜ä¸€ã‚»ãƒ«</option>
                                    </select>
                                </div>
                                <div>
                                    <label>è‰²ã‚’é¸æŠ:</label>
                                    <div class="color-picker" id="colorPicker"></div>
                                    <label style="margin-top: 10px;">ã¾ãŸã¯ä»»æ„ã®è‰²ã‚’æŒ‡å®š:</label>
                                    <input type="color" id="customColorPicker" value="#FF6B6B" style="width: 100%; height: 40px; cursor: pointer;">
                                </div>
                                <button onclick="createCustomObstacle()" id="createObstacleBtn">ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆ</button>
                                <button onclick="cancelCustomObstacleForm()" class="secondary">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                                <div id="tempShapeMessage" style="display: none;" class="temp-message">
                                    å½¢çŠ¶ã‚’å…¥åŠ›ã—çµ‚ã‚ã£ãŸã‚‰ã€å†åº¦ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„
                                </div>
                            </div>
                        </div>
                        
                        <div id="obstacleList" style="max-height: 200px; overflow-y: auto; margin-top: 12px;"></div>
                        <button onclick="deleteSelectedObstacles()" style="background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%); margin-top: 8px;">ğŸ—‘ï¸ é¸æŠå‰Šé™¤</button>
                    </div>
                </div>
                
                <!-- å³ã‚«ãƒ©ãƒ  -->
                <div class="right-column">
                    <!-- åº§æ¨™ç®¡ç† -->
                    <div class="section">
                        <h2>ğŸ“‹ ä¿å­˜æ¸ˆã¿åº§æ¨™</h2>
                        
                        <!-- ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ»ã‚½ãƒ¼ãƒˆ -->
                        <div class="filter-controls">
                            <input type="text" id="nameFilter" placeholder="åç§°æ¤œç´¢" onkeyup="applyFilters()" style="width: 100%;">
                        </div>
                        <div class="filter-controls" style="display: flex; gap: 10px; align-items: center;">
                            <input type="date" id="dateFilterFrom" onchange="applyFilters()" style="flex: 1;">
                            <span>ã‹ã‚‰</span>
                            <input type="date" id="dateFilterTo" onchange="applyFilters()" style="flex: 1;">
                        </div>
                        <div class="filter-controls" style="display: flex; gap: 5px; margin-top: 5px;">
                            <button onclick="setDateFilter('today')" class="secondary" style="flex: 1; padding: 6px;">ä»Šæ—¥</button>
                            <button onclick="setDateFilter('week')" class="secondary" style="flex: 1; padding: 6px;">ä»Šé€±</button>
                            <button onclick="setDateFilter('month')" class="secondary" style="flex: 1; padding: 6px;">ä»Šæœˆ</button>
                            <button onclick="setDateFilter('year')" class="secondary" style="flex: 1; padding: 6px;">ä»Šå¹´</button>
                        </div>
                        <div class="filter-controls">
                            <select id="sortBy" onchange="applyFilters()">
                                <option value="date-desc">ç™»éŒ²æ—¥æ™‚(æ–°â†’å¤)</option>
                                <option value="date-asc">ç™»éŒ²æ—¥æ™‚(å¤â†’æ–°)</option>
                                <option value="name-asc">åå‰(Aâ†’Z)</option>
                                <option value="name-desc">åå‰(Zâ†’A)</option>
                                <option value="x-asc">Xåº§æ¨™(å°â†’å¤§)</option>
                                <option value="x-desc">Xåº§æ¨™(å¤§â†’å°)</option>
                                <option value="y-asc">Yåº§æ¨™(å°â†’å¤§)</option>
                                <option value="y-desc">Yåº§æ¨™(å¤§â†’å°)</option>
                            </select>
                            <button onclick="clearFilters()" class="secondary" style="width: auto; padding: 8px 16px; margin: 0;">ãƒ•ã‚£ãƒ«ã‚¿è§£é™¤</button>
                        </div>
                        
                        <div class="toggle-switch">
                            <span>ä¸€æ‹¬é¸æŠãƒ¢ãƒ¼ãƒ‰</span>
                            <input type="checkbox" id="rangeSelectMode" onchange="toggleRangeSelectMode()">
                        </div>
                        
                        <div id="coordinateList" style="max-height: 300px; overflow-y: auto;"></div>
                        <div class="map-controls" style="margin-top: 12px;">
                            <button onclick="hideSelectedCoordinates()" class="secondary">ğŸ‘ï¸ é¸æŠæ¸ˆã¿ã‚’éè¡¨ç¤º</button>
                            <button onclick="showAllCoordinates()" class="secondary">ğŸ‘ï¸ ã™ã¹ã¦è¡¨ç¤º</button>
                            <button onclick="toggleDuplicateCoordinates()" class="secondary" id="toggleDuplicateBtn">ğŸ‘ï¸ é‡è¤‡åº§æ¨™ã‚’éè¡¨ç¤º</button>
                            <button onclick="deleteSelectedCoordinates()" style="background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);">ğŸ—‘ï¸ é¸æŠå‰Šé™¤</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        
        // ã‚²ãƒ¼ãƒ å…¨ä½“ã®åº§æ¨™ç¯„å›²
        const worldBounds = {
            minX: 0,
            maxX: 700,
            minY: 0,
            maxY: 1900
        };
        
        // ä¸€ç´šåœ°å¸¯ã®ç¯„å›²
        const primeZone = {
            minX: 200,
            maxX: 439,
            minY: 760,
            maxY: 999
        };
        
        // åŸã®å›ºå®šãƒ‡ãƒ¼ã‚¿
        const castles = [
            { name: 'äºŒæ¡åŸ', x: 320, y: 880 },
            { name: 'é›‘è³€åŸ', x: 416, y: 785 },
            { name: 'å¾Œç€¬å±±åŸ', x: 220, y: 860 },
            { name: 'ä¼Šè³€ä¸Šé‡åŸ', x: 388, y: 949 }
        ];
        
        // æç”»è¨­å®š
        let scale = 5;
        let offsetX = (primeZone.minX + primeZone.maxX) / 2;
        let offsetY = (primeZone.minY + primeZone.maxY) / 2;
        let gridType = 'square';
        
        // ãƒ‡ãƒ¼ã‚¿
        let parsedCoordinates = [];
        let savedCoordinates = [];
        let selectedCoordinateIds = new Set();
        let hiddenCoordinateIds = new Set();
        let duplicateCoordinateIds = new Set();
        let coordinateGroups = [];
        let filteredCoordinates = [];
        let obstacles = [];
        let selectedObstacleIds = new Set();
        let customObstacles = [];
        
        // UIçŠ¶æ…‹
        let currentMode = 'view';
        let selectedObstacleType = null;
        let tempSelection = new Set();
        let isCreatingCustomObstacle = false;
        let customObstacleInProgress = null;
        let rangeSelectMode = false;
        let rangeSelectStart = null;
        let expandedGroupId = null;
        let groupFilterActive = false;
        
        // ãƒ‰ãƒ©ãƒƒã‚°é¸æŠç”¨
        let isDragging = false;
        let dragStartCell = null;
        let dragCurrentCell = null;
        
        // åº§æ¨™èª¿æ•´ãƒ¢ãƒ¼ãƒ‰ç”¨
        let adjustMode = {
            active: false,
            groupName: '',
            coordinates: []
        };
        let draggedCoordinate = null;
        
        // éšœå®³ç‰©ã®åå‰
        const obstacleNames = {
            'rock': 'ğŸª¨ å²©'
        };
        
        // ã‚¿ãƒƒãƒæ“ä½œç”¨
        let touches = [];
        let lastTouchDistance = 0;
        let isPanning = false;
        let lastPanPos = null;
        
        // ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ç”¨ã®è‰²ãƒ‘ãƒ¬ãƒƒãƒˆ
        const colorPalette = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
            '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B88B', '#AAB7B8',
            '#FF8ED4', '#00D2FF', '#3F51B5', '#E91E63', '#009688'
        ];
        
        // åˆæœŸåŒ–
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            initColorPicker();
            createDefaultGroup();
            
            // ä¿®æ­£3: ãƒ­ãƒ¼ã‚«ãƒ«ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã§æ—¥ä»˜ã‚’è¨­å®š
            const today = new Date();
            const dateString = getLocalDateString(today);
            document.getElementById('dateFilterTo').value = dateString;
            
            drawMap();
            updateStats();
        }
        
        // ä¿®æ­£3: ãƒ­ãƒ¼ã‚«ãƒ«ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã§æ—¥ä»˜æ–‡å­—åˆ—ã‚’å–å¾—
        function getLocalDateString(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚°ãƒ«ãƒ¼ãƒ—ã®ä½œæˆ
        function createDefaultGroup() {
            coordinateGroups.push({
                id: 'default',
                name: 'ç™»éŒ²æ¸ˆã¿åº§æ¨™',
                coordinateIds: [],
                createdAt: new Date().toISOString()
            });
            updateGroupsList();
        }
        
        // æ—¥ä»˜ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ (ä¿®æ­£3å¯¾å¿œ)
        function setDateFilter(period) {
            const today = new Date();
            const dateFilterFrom = document.getElementById('dateFilterFrom');
            const dateFilterTo = document.getElementById('dateFilterTo');
            
            // çµ‚äº†æ—¥ã¯å¸¸ã«ä»Šæ—¥
            dateFilterTo.value = getLocalDateString(today);
            
            let startDate = new Date();
            switch(period) {
                case 'today':
                    startDate = new Date(today);
                    break;
                case 'week':
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - today.getDay());
                    break;
                case 'month':
                    startDate = new Date(today.getFullYear(), today.getMonth(), 1);
                    break;
                case 'year':
                    startDate = new Date(today.getFullYear(), 0, 1);
                    break;
            }
            
            dateFilterFrom.value = getLocalDateString(startDate);
            applyFilters();
        }
        
        // ç‰¹å®šã®æ—¥ä»˜ã§çµã‚Šè¾¼ã¿
        function filterByDate(dateISO) {
            const dateFilterFrom = document.getElementById('dateFilterFrom');
            const dateFilterTo = document.getElementById('dateFilterTo');
            
            dateFilterFrom.value = dateISO;
            dateFilterTo.value = dateISO;
            applyFilters();
        }
        
        // è‰²ãƒ”ãƒƒã‚«ãƒ¼ã®åˆæœŸåŒ–
        function initColorPicker() {
            const picker = document.getElementById('colorPicker');
            picker.innerHTML = '';
            colorPalette.forEach((color, index) => {
                const div = document.createElement('div');
                div.className = 'color-option' + (index === 0 ? ' selected' : '');
                div.style.backgroundColor = color;
                div.onclick = () => selectColor(div, color);
                picker.appendChild(div);
            });
        }
        
        function selectColor(element, color) {
            document.querySelectorAll('.color-option').forEach(el => el.classList.remove('selected'));
            element.classList.add('selected');
        }
        
        function getSelectedColor() {
            const selected = document.querySelector('.color-option.selected');
            if (selected) {
                return selected.style.backgroundColor;
            }
            const customPicker = document.getElementById('customColorPicker');
            if (customPicker) {
                return customPicker.value;
            }
            return colorPalette[0];
        }
        
        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ãƒªã‚µã‚¤ã‚º (ä¿®æ­£2å¯¾å¿œ)
        function resizeCanvas() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            
            const dpr = window.devicePixelRatio || 1;
            
            // ä¿®æ­£2: å…¨ç”»é¢è¡¨ç¤ºæ™‚ã¯ç”»é¢ã‚µã‚¤ã‚ºã‚’ä½¿ç”¨
            let displayWidth, displayHeight;
            if (document.fullscreenElement) {
                displayWidth = window.innerWidth;
                displayHeight = window.innerHeight;
            } else {
                displayWidth = rect.width - 40;
                displayHeight = Math.min(600, window.innerHeight * 0.5);
            }
            
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
            
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            ctx.scale(dpr, dpr);
            
            drawMap();
        }
        
        // åº§æ¨™å¤‰æ›(ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™â†’ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™)
        function worldToScreen(x, y) {
            const dpr = window.devicePixelRatio || 1;
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;
            
            if (gridType === 'diamond') {
                const dx = x - offsetX;
                const dy = y - offsetY;
                
                const screenX = width / 2 + (dx + dy) * scale / 2;
                const screenY = height / 2 + (dx - dy) * scale * 0.876 / 2;
                
                return { x: screenX, y: screenY };
            } else {
                return {
                    x: width / 2 + (y - offsetY) * scale,
                    y: height / 2 + (x - offsetX) * scale
                };
            }
        }
        
        // åº§æ¨™å¤‰æ›(ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™â†’ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™)
        function screenToWorld(screenX, screenY) {
            const dpr = window.devicePixelRatio || 1;
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;
            
            if (gridType === 'diamond') {
                const sx = (screenX - width / 2) / scale * 2;
                const sy = (screenY - height / 2) / scale / 0.876 * 2;
                
                const worldX = offsetX + (sx + sy) / 2;
                const worldY = offsetY + (sx - sy) / 2;
                
                return {
                    x: Math.round(worldX),
                    y: Math.round(worldY)
                };
            } else {
                return {
                    x: Math.round(offsetX + (screenY - height / 2) / scale),
                    y: Math.round(offsetY + (screenX - width / 2) / scale)
                };
            }
        }
        
        // ã‚°ãƒªãƒƒãƒ‰ã‚¿ã‚¤ãƒ—ã®å¤‰æ›´
        function changeGridType(type) {
            gridType = type;
            resizeCanvas();
        }
        
        // ãƒ¢ãƒ¼ãƒ‰å¤‰æ›´
        function changeMode(mode) {
            if (mode === 'adjust' && !adjustMode.active) {
                startAdjustMode();
                return;
            }
            
            currentMode = mode;
            tempSelection.clear();
            draggedCoordinate = null;
            isDragging = false;
            dragStartCell = null;
            
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            if (mode === 'input') {
                canvas.style.cursor = 'crosshair';
            } else if (mode === 'adjust') {
                canvas.style.cursor = 'move';
            } else if (mode === 'delete') {
                canvas.style.cursor = 'not-allowed';
            } else {
                canvas.style.cursor = 'default';
            }
            
            drawMap();
        }
        
        // åº§æ¨™èª¿æ•´ãƒ¢ãƒ¼ãƒ‰é–‹å§‹
        function startAdjustMode() {
            if (savedCoordinates.length === 0) {
                alert('èª¿æ•´ã™ã‚‹åº§æ¨™ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            adjustMode.active = true;
            adjustMode.coordinates = savedCoordinates.map(c => ({...c}));
            
            const timestamp = new Date();
            const dateStr = timestamp.toISOString().replace(/[-:T]/g, '').split('.')[0];
            adjustMode.groupName = `åº§æ¨™èª¿æ•´_${dateStr}`;
            
            document.getElementById('adjustGroupName').value = adjustMode.groupName;
            document.getElementById('adjustModePanel').style.display = 'block';
            
            currentMode = 'adjust';
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector('.mode-btn:nth-child(3)').classList.add('active');
            canvas.style.cursor = 'move';
            
            drawMap();
        }
        
        // èª¿æ•´åº§æ¨™ã‚’ä¿å­˜
        function saveAdjustedGroup() {
            const groupName = document.getElementById('adjustGroupName').value.trim();
            if (!groupName) {
                alert('ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            const coordIds = [];
            adjustMode.coordinates.forEach((c, i) => {
                const newCoord = {
                    ...c,
                    id: Date.now() + Math.random() + i,
                    createdAt: new Date().toISOString()
                };
                savedCoordinates.push(newCoord);
                coordIds.push(newCoord.id);
            });
            
            coordinateGroups.push({
                id: Date.now().toString(),
                name: groupName,
                coordinateIds: coordIds,
                createdAt: new Date().toISOString()
            });
            
            cancelAdjustMode();
            updateCoordinatesList();
            updateGroupsList();
            updateStats();
            drawMap();
            
            alert('èª¿æ•´åº§æ¨™ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
        }
        
        // åº§æ¨™èª¿æ•´ãƒ¢ãƒ¼ãƒ‰ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        function cancelAdjustMode() {
            adjustMode.active = false;
            adjustMode.coordinates = [];
            adjustMode.groupName = '';
            document.getElementById('adjustModePanel').style.display = 'none';
            changeMode('view');
        }
        
        // ãƒã‚¦ã‚¹ãƒ€ã‚¦ãƒ³
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const worldPos = screenToWorld(x, y);
            
            if (currentMode === 'view') {
                // ä¿®æ­£5: ã²ã—å½¢ãƒ¢ãƒ¼ãƒ‰ã§ã®ãƒ‘ãƒ³æ“ä½œ
                isPanning = true;
                lastPanPos = { x: e.clientX, y: e.clientY };
            } else if (currentMode === 'input') {
                if (selectedObstacleType) {
                    const customObstacle = customObstacles.find(o => o.id === selectedObstacleType);
                    if (customObstacle && selectedObstacleType !== 'temp_custom') {
                        handleInputClick(worldPos);
                    } else {
                        isDragging = true;
                        dragStartCell = worldPos;
                        dragCurrentCell = worldPos;
                        
                        const key = `${worldPos.x},${worldPos.y}`;
                        const existingObstacle = obstacles.find(o => o.cells.includes(key) && o.type === selectedObstacleType);
                        dragStartCell.isObstacle = !!existingObstacle;
                    }
                } else {
                    handleInputClick(worldPos);
                }
            } else if (currentMode === 'adjust') {
                handleAdjustStart(worldPos, { x, y });
            } else if (currentMode === 'delete') {
                if (selectedObstacleType) {
                    isDragging = true;
                    dragStartCell = worldPos;
                    dragCurrentCell = worldPos;
                } else {
                    handleDeleteClick(worldPos);
                }
            }
        }
        
        // ãƒã‚¦ã‚¹ãƒ ãƒ¼ãƒ–
        function handleMouseMove(e) {
            if (currentMode === 'view' && isPanning && lastPanPos) {
                // ä¿®æ­£5: ã²ã—å½¢ãƒ¢ãƒ¼ãƒ‰ã§ã‚‚ç”»é¢åº§æ¨™ç³»ã§ãƒ‘ãƒ³æ“ä½œ
                const dx = e.clientX - lastPanPos.x;
                const dy = e.clientY - lastPanPos.y;
                
                if (gridType === 'diamond') {
                    // ã²ã—å½¢ãƒ¢ãƒ¼ãƒ‰: ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã®ç§»å‹•é‡ã‚’ä¸–ç•Œåº§æ¨™ã«å¤‰æ›
                    const screenDelta = { x: dx, y: dy };
                    const worldDelta = screenToWorldDelta(screenDelta);
                    offsetX -= worldDelta.x;
                    offsetY -= worldDelta.y;
                } else {
                    // æ­£æ–¹å½¢ãƒ¢ãƒ¼ãƒ‰: å¾“æ¥é€šã‚Š
                    offsetX -= dy / scale;
                    offsetY -= dx / scale;
                }
                
                lastPanPos = { x: e.clientX, y: e.clientY };
                drawMap();
            } else if ((currentMode === 'input' || currentMode === 'delete') && isDragging && dragStartCell) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = screenToWorld(x, y);
                
                dragCurrentCell = worldPos;
                updateDragSelection();
                drawMap();
            } else if (currentMode === 'adjust' && draggedCoordinate) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = screenToWorld(x, y);
                
                draggedCoordinate.x = worldPos.x;
                draggedCoordinate.y = worldPos.y;
                drawMap();
            }
        }
        
        // ä¿®æ­£5: ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã®ãƒ‡ãƒ«ã‚¿ã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã®ãƒ‡ãƒ«ã‚¿ã«å¤‰æ›
        function screenToWorldDelta(screenDelta) {
            if (gridType === 'diamond') {
                const sx = screenDelta.x / scale * 2;
                const sy = screenDelta.y / scale / 0.876 * 2;
                
                return {
                    x: (sx + sy) / 2,
                    y: (sx - sy) / 2
                };
            } else {
                return {
                    x: screenDelta.y / scale,
                    y: screenDelta.x / scale
                };
            }
        }
        
        // ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—
        function handleMouseUp(e) {
            if (currentMode === 'view') {
                isPanning = false;
                lastPanPos = null;
            } else if ((currentMode === 'input' || currentMode === 'delete') && isDragging) {
                if (dragStartCell && dragCurrentCell && 
                    dragStartCell.x === dragCurrentCell.x && 
                    dragStartCell.y === dragCurrentCell.y) {
                    updateDragSelection();
                }
                
                if (selectedObstacleType && selectedObstacleType !== 'temp_custom') {
                    // ä¿®æ­£1: currentModeã‚’å¼•æ•°ã¨ã—ã¦æ¸¡ã™
                    confirmDragObstacle(currentMode);
                }
                isDragging = false;
                dragStartCell = null;
                dragCurrentCell = null;
            } else if (currentMode === 'adjust' && draggedCoordinate) {
                draggedCoordinate = null;
                drawMap();
            }
        }
        
        // ãƒ‰ãƒ©ãƒƒã‚°é¸æŠã®æ›´æ–°
        function updateDragSelection() {
            if (!dragStartCell || !dragCurrentCell) return;
            
            tempSelection.clear();
            
            const minX = Math.min(dragStartCell.x, dragCurrentCell.x);
            const maxX = Math.max(dragStartCell.x, dragCurrentCell.x);
            const minY = Math.min(dragStartCell.y, dragCurrentCell.y);
            const maxY = Math.max(dragStartCell.y, dragCurrentCell.y);
            
            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    const key = `${x},${y}`;
                    tempSelection.add(key);
                }
            }
        }
        
        // ä¿®æ­£1: ãƒ‰ãƒ©ãƒƒã‚°éšœå®³ç‰©ã®ç¢ºå®š - currentModeã‚’å¼•æ•°ã¨ã—ã¦å—ã‘å–ã‚‹
        function confirmDragObstacle(mode) {
            if (tempSelection.size === 0) return;
            
            // ä¿®æ­£1: dragStartCell.isObstacleã§ã¯ãªãmodeã‹ã‚‰åˆ¤å®š
            const isAddMode = (mode !== 'delete');
            
            tempSelection.forEach(key => {
                const existingObstacle = obstacles.find(o => o.cells.includes(key) && o.type === selectedObstacleType);
                
                if (isAddMode) {
                    if (!existingObstacle) {
                        let found = false;
                        for (let obstacle of obstacles) {
                            if (obstacle.type === selectedObstacleType) {
                                obstacle.cells.push(key);
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            obstacles.push({
                                id: Date.now() + Math.random(),
                                type: selectedObstacleType,
                                cells: [key]
                            });
                        }
                    }
                } else {
                    if (existingObstacle) {
                        existingObstacle.cells = existingObstacle.cells.filter(c => c !== key);
                    }
                }
            });
            
            obstacles = obstacles.filter(o => o.cells.length > 0);
            
            tempSelection.clear();
            groupObstacles();
            updateObstaclesList();
            updateStats();
            drawMap();
        }
        
        // ãƒ›ã‚¤ãƒ¼ãƒ«(ã‚ºãƒ¼ãƒ )
        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            scale = Math.max(0.5, Math.min(20, scale * delta));
            drawMap();
        }
        
        // ã‚¿ãƒƒãƒã‚¹ã‚¿ãƒ¼ãƒˆ
        function handleTouchStart(e) {
            e.preventDefault();
            touches = Array.from(e.touches);
            
            if (touches.length === 1) {
                const touch = touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                const worldPos = screenToWorld(x, y);
                
                if (currentMode === 'input') {
                    if (selectedObstacleType) {
                        const customObstacle = customObstacles.find(o => o.id === selectedObstacleType);
                        if (customObstacle && selectedObstacleType !== 'temp_custom') {
                            handleInputClick(worldPos);
                        } else {
                            isDragging = true;
                            dragStartCell = worldPos;
                            dragCurrentCell = worldPos;
                            
                            const key = `${worldPos.x},${worldPos.y}`;
                            const existingObstacle = obstacles.find(o => o.cells.includes(key) && o.type === selectedObstacleType);
                            dragStartCell.isObstacle = !!existingObstacle;
                        }
                    } else {
                        handleInputClick(worldPos);
                    }
                } else if (currentMode === 'adjust') {
                    handleAdjustStart(worldPos, { x, y });
                } else if (currentMode === 'delete') {
                    if (selectedObstacleType) {
                        isDragging = true;
                        dragStartCell = worldPos;
                        dragCurrentCell = worldPos;
                    } else {
                        handleDeleteClick(worldPos);
                    }
                }
            } else if (touches.length === 2) {
                const dx = touches[1].clientX - touches[0].clientX;
                const dy = touches[1].clientY - touches[0].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                
                const centerX = (touches[0].clientX + touches[1].clientX) / 2;
                const centerY = (touches[0].clientY + touches[1].clientY) / 2;
                lastPanPos = { x: centerX, y: centerY };
                isPanning = true;
            }
        }
        
        // ã‚¿ãƒƒãƒãƒ ãƒ¼ãƒ–
        function handleTouchMove(e) {
            e.preventDefault();
            touches = Array.from(e.touches);
            
            if (touches.length === 2) {
                const dx = touches[1].clientX - touches[0].clientX;
                const dy = touches[1].clientY - touches[0].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (lastTouchDistance > 0) {
                    const delta = distance / lastTouchDistance;
                    scale = Math.max(0.5, Math.min(20, scale * delta));
                }
                lastTouchDistance = distance;
                
                if (isPanning && lastPanPos) {
                    const centerX = (touches[0].clientX + touches[1].clientX) / 2;
                    const centerY = (touches[0].clientY + touches[1].clientY) / 2;
                    
                    const panDx = centerX - lastPanPos.x;
                    const panDy = centerY - lastPanPos.y;
                    
                    // ä¿®æ­£5: ã‚¿ãƒƒãƒãƒ‘ãƒ³æ“ä½œã‚‚ã²ã—å½¢ãƒ¢ãƒ¼ãƒ‰ã«å¯¾å¿œ
                    if (gridType === 'diamond') {
                        const screenDelta = { x: panDx, y: panDy };
                        const worldDelta = screenToWorldDelta(screenDelta);
                        offsetX -= worldDelta.x;
                        offsetY -= worldDelta.y;
                    } else {
                        offsetX -= panDy / scale;
                        offsetY -= panDx / scale;
                    }
                    
                    lastPanPos = { x: centerX, y: centerY };
                }
                
                drawMap();
            } else if (touches.length === 1) {
                if ((currentMode === 'input' || currentMode === 'delete') && isDragging && dragStartCell) {
                    const touch = touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    const worldPos = screenToWorld(x, y);
                    
                    dragCurrentCell = worldPos;
                    updateDragSelection();
                    drawMap();
                } else if (currentMode === 'adjust' && draggedCoordinate) {
                    const touch = touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    const worldPos = screenToWorld(x, y);
                    
                    draggedCoordinate.x = worldPos.x;
                    draggedCoordinate.y = worldPos.y;
                    drawMap();
                }
            }
        }
        
        // ã‚¿ãƒƒãƒã‚¨ãƒ³ãƒ‰
        function handleTouchEnd(e) {
            e.preventDefault();
            touches = Array.from(e.touches);
            
            if (touches.length < 2) {
                lastTouchDistance = 0;
                isPanning = false;
                lastPanPos = null;
            }
            
            if (touches.length === 0) {
                if ((currentMode === 'input' || currentMode === 'delete') && isDragging) {
                    if (dragStartCell && dragCurrentCell && 
                        dragStartCell.x === dragCurrentCell.x && 
                        dragStartCell.y === dragCurrentCell.y) {
                        updateDragSelection();
                    }
                    
                    if (selectedObstacleType && selectedObstacleType !== 'temp_custom') {
                        // ä¿®æ­£1: currentModeã‚’å¼•æ•°ã¨ã—ã¦æ¸¡ã™
                        confirmDragObstacle(currentMode);
                    }
                    isDragging = false;
                    dragStartCell = null;
                    dragCurrentCell = null;
                } else if (currentMode === 'adjust' && draggedCoordinate) {
                    draggedCoordinate = null;
                    drawMap();
                }
            }
        }
        
        // å…¥åŠ›ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        function handleInputClick(worldPos) {
            if (!selectedObstacleType) return;
            
            const key = `${worldPos.x},${worldPos.y}`;
            
            const customObstacle = customObstacles.find(o => o.id === selectedObstacleType);
            if (customObstacle && customObstacle.shape && customObstacle.shape.length > 0) {
                customObstacle.shape.forEach(cell => {
                    const [dx, dy] = cell.split(',').map(Number);
                    const targetKey = `${worldPos.x + dx},${worldPos.y + dy}`;
                    tempSelection.add(targetKey);
                });
                
                if (selectedObstacleType !== 'temp_custom') {
                    // ä¿®æ­£1: currentModeã‚’å¼•æ•°ã¨ã—ã¦æ¸¡ã™
                    confirmDragObstacle(currentMode);
                }
            }
        }
        
        // åº§æ¨™èª¿æ•´é–‹å§‹
        function handleAdjustStart(worldPos, screenPos) {
            const dataSource = adjustMode.active ? adjustMode.coordinates : savedCoordinates;
            const hitRadius = 10;
            
            let closestCoord = null;
            let minDistance = Infinity;
            
            for (const coord of dataSource) {
                if (!adjustMode.active && hiddenCoordinateIds.has(coord.id)) continue;
                
                const dx = coord.x - worldPos.x;
                const dy = coord.y - worldPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (Math.abs(dx) <= hitRadius && Math.abs(dy) <= hitRadius) {
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestCoord = coord;
                    }
                }
            }
            
            if (closestCoord) {
                draggedCoordinate = closestCoord;
            }
        }
        
        // å‰Šé™¤ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        function handleDeleteClick(worldPos) {
            const coord = savedCoordinates.find(c => c.x === worldPos.x && c.y === worldPos.y);
            if (coord) {
                if (confirm(`${coord.name} ã‚’å‰Šé™¤ã—ã¾ã™ã‹?`)) {
                    savedCoordinates = savedCoordinates.filter(c => c.id !== coord.id);
                    selectedCoordinateIds.delete(coord.id);
                    updateCoordinatesList();
                    updateStats();
                    drawMap();
                }
            }
        }
        
        // ãƒãƒƒãƒ—æç”»
        function drawMap() {
            const dpr = window.devicePixelRatio || 1;
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;
            
            ctx.clearRect(0, 0, width, height);
            
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(0, 0, width, height);
            
            drawPrimeZoneBackground();
            
            if (gridType === 'diamond') {
                drawDiamondGrid();
            } else {
                drawSquareGrid();
            }
            
            castles.forEach(castle => {
                drawCastle(castle);
            });
            
            const coordsToDisplay = adjustMode.active ? adjustMode.coordinates : savedCoordinates;
            
            coordsToDisplay.forEach(coord => {
                if (!adjustMode.active && hiddenCoordinateIds.has(coord.id)) return;
                drawResidenceArea(coord);
            });
            
            obstacles.forEach(obstacle => {
                drawObstacle(obstacle);
            });
            
            if ((currentMode === 'input' || currentMode === 'delete') && tempSelection.size > 0) {
                tempSelection.forEach(key => {
                    const [x, y] = key.split(',').map(Number);
                    const color = isCreatingCustomObstacle && customObstacleInProgress 
                        ? customObstacleInProgress.color 
                        : (selectedObstacleType ? getObstacleColor(selectedObstacleType) : 'rgba(255, 0, 0, 0.3)');
                    drawCell(x, y, color);
                });
            }
            
            coordsToDisplay.forEach(coord => {
                if (!adjustMode.active && hiddenCoordinateIds.has(coord.id)) return;
                drawCoordinateMarker(coord);
            });
            
            if (draggedCoordinate) {
                drawCoordinateMarker(draggedCoordinate, true);
            }
        }
        
        // ä¸€ç´šåœ°å¸¯ã®èƒŒæ™¯æç”»
        function drawPrimeZoneBackground() {
            if (gridType === 'diamond') {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.15)';
                ctx.beginPath();
                
                const topLeft = worldToScreen(primeZone.minX, primeZone.minY);
                const topRight = worldToScreen(primeZone.minX, primeZone.maxY + 1);
                const bottomRight = worldToScreen(primeZone.maxX + 1, primeZone.maxY + 1);
                const bottomLeft = worldToScreen(primeZone.maxX + 1, primeZone.minY);
                
                ctx.moveTo(topLeft.x, topLeft.y);
                ctx.lineTo(topRight.x, topRight.y);
                ctx.lineTo(bottomRight.x, bottomRight.y);
                ctx.lineTo(bottomLeft.x, bottomLeft.y);
                ctx.closePath();
                ctx.fill();
            } else {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.15)';
                const pos1 = worldToScreen(primeZone.minX, primeZone.minY);
                const pos2 = worldToScreen(primeZone.maxX + 1, primeZone.maxY + 1);
                ctx.fillRect(pos1.x, pos1.y, pos2.x - pos1.x, pos2.y - pos1.y);
            }
        }
        
        // æ­£æ–¹å½¢ã‚°ãƒªãƒƒãƒ‰æç”»
        function drawSquareGrid() {
            const dpr = window.devicePixelRatio || 1;
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;
            
            ctx.lineWidth = 1;
            
            const visibleMinX = Math.floor(offsetX - height / scale / 2);
            const visibleMaxX = Math.ceil(offsetX + height / scale / 2);
            const visibleMinY = Math.floor(offsetY - width / scale / 2);
            const visibleMaxY = Math.ceil(offsetY + width / scale / 2);
            
            for (let x = Math.max(worldBounds.minX, visibleMinX); x <= Math.min(worldBounds.maxX, visibleMaxX) + 1; x++) {
                const pos1 = worldToScreen(x, visibleMinY);
                const pos2 = worldToScreen(x, visibleMaxY);
                
                ctx.strokeStyle = x % 10 === 0 ? '#888' : '#d0d0d0';
                ctx.beginPath();
                ctx.moveTo(pos1.x, Math.floor(pos1.y) + 0.5);
                ctx.lineTo(pos2.x, Math.floor(pos2.y) + 0.5);
                ctx.stroke();
            }
            
            for (let y = Math.max(worldBounds.minY, visibleMinY); y <= Math.min(worldBounds.maxY, visibleMaxY) + 1; y++) {
                const pos1 = worldToScreen(visibleMinX, y);
                const pos2 = worldToScreen(visibleMaxX, y);
                
                ctx.strokeStyle = y % 10 === 0 ? '#888' : '#d0d0d0';
                ctx.beginPath();
                ctx.moveTo(Math.floor(pos1.x) + 0.5, pos1.y);
                ctx.lineTo(Math.floor(pos2.x) + 0.5, pos2.y);
                ctx.stroke();
            }
        }
        
        // ã²ã—å½¢ã‚°ãƒªãƒƒãƒ‰æç”»
        function drawDiamondGrid() {
            const dpr = window.devicePixelRatio || 1;
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;
            
            ctx.lineWidth = 1;
            
            const visibleRange = Math.max(width, height) / scale + 50;
            const visibleMinX = Math.floor(offsetX - visibleRange);
            const visibleMaxX = Math.ceil(offsetX + visibleRange);
            const visibleMinY = Math.floor(offsetY - visibleRange);
            const visibleMaxY = Math.ceil(offsetY + visibleRange);
            
            for (let x = Math.max(worldBounds.minX, visibleMinX); x <= Math.min(worldBounds.maxX, visibleMaxX) + 1; x++) {
                for (let y = Math.max(worldBounds.minY, visibleMinY); y <= Math.min(worldBounds.maxY, visibleMaxY) + 1; y++) {
                    const pos = worldToScreen(x, y);
                    
                    if (pos.x < -100 || pos.x > width + 100 || pos.y < -100 || pos.y > height + 100) {
                        continue;
                    }
                    
                    ctx.strokeStyle = (x % 10 === 0 || y % 10 === 0) ? '#888' : '#d0d0d0';
                    
                    if (y <= Math.min(worldBounds.maxY, visibleMaxY)) {
                        const posRight = worldToScreen(x, y + 1);
                        ctx.beginPath();
                        ctx.moveTo(Math.floor(pos.x) + 0.5, Math.floor(pos.y) + 0.5);
                        ctx.lineTo(Math.floor(posRight.x) + 0.5, Math.floor(posRight.y) + 0.5);
                        ctx.stroke();
                    }
                    
                    if (x <= Math.min(worldBounds.maxX, visibleMaxX)) {
                        const posDown = worldToScreen(x + 1, y);
                        ctx.beginPath();
                        ctx.moveTo(Math.floor(pos.x) + 0.5, Math.floor(pos.y) + 0.5);
                        ctx.lineTo(Math.floor(posDown.x) + 0.5, Math.floor(posDown.y) + 0.5);
                        ctx.stroke();
                    }
                }
            }
        }
        
        // ã‚»ãƒ«æç”»
        function drawCell(x, y, color) {
            if (gridType === 'diamond') {
                drawDiamondCell(x, y, color);
            } else {
                drawSquareCell(x, y, color);
            }
        }
        
        // æ­£æ–¹å½¢ã‚»ãƒ«æç”»
        function drawSquareCell(x, y, color) {
            const topLeft = worldToScreen(x, y);
            const bottomRight = worldToScreen(x + 1, y + 1);
            const width = bottomRight.x - topLeft.x;
            const height = bottomRight.y - topLeft.y;
            
            ctx.fillStyle = color;
            ctx.fillRect(topLeft.x, topLeft.y, width, height);
        }
        
        // ã²ã—å½¢ã‚»ãƒ«æç”»
        function drawDiamondCell(x, y, color) {
            const topLeft = worldToScreen(x, y);
            const topRight = worldToScreen(x, y + 1);
            const bottomRight = worldToScreen(x + 1, y + 1);
            const bottomLeft = worldToScreen(x + 1, y);
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(topLeft.x, topLeft.y);
            ctx.lineTo(topRight.x, topRight.y);
            ctx.lineTo(bottomRight.x, bottomRight.y);
            ctx.lineTo(bottomLeft.x, bottomLeft.y);
            ctx.closePath();
            ctx.fill();
        }
        
        // åŸã®æç”»
        function drawCastle(castle) {
            const { x, y } = castle;
            
            for (let dx = -4; dx <= 4; dx++) {
                for (let dy = -4; dy <= 4; dy++) {
                    drawCell(x + dx, y + dy, 'rgba(128, 0, 128, 0.6)');
                }
            }
            
            for (let dx = -8; dx <= 8; dx++) {
                for (let dy = -8; dy <= 8; dy++) {
                    if (Math.abs(dx) > 4 || Math.abs(dy) > 4) {
                        drawCell(x + dx, y + dy, 'rgba(200, 150, 200, 0.3)');
                    }
                }
            }
        }
        
        // å±…ä½ç¯„å›²ã®æç”»
        function drawResidenceArea(coord) {
            const { x, y } = coord;
            const range = 10;
            
            for (let dx = -range; dx <= range; dx++) {
                for (let dy = -range; dy <= range; dy++) {
                    drawCell(x + dx, y + dy, 'rgba(100, 200, 100, 0.1)');
                }
            }
        }
        
        // éšœå®³ç‰©ã®è‰²å–å¾—
        function getObstacleColor(type) {
            if (type === 'rock') {
                return 'rgba(128, 128, 128, 0.6)';
            }
            
            const custom = customObstacles.find(o => o.id === type);
            if (custom) {
                const color = custom.color;
                
                if (color.startsWith('#')) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.6)`;
                }
                
                const rgb = color.match(/\d+/g);
                if (rgb && rgb.length >= 3) {
                    return `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.6)`;
                }
                
                return color;
            }
            
            return 'rgba(128, 128, 128, 0.6)';
        }
        
        // éšœå®³ç‰©æç”»
        function drawObstacle(obstacle) {
            const color = getObstacleColor(obstacle.type);
            
            obstacle.cells.forEach(cell => {
                const [x, y] = cell.split(',').map(Number);
                drawCell(x, y, color);
            });
        }
        
        // åº§æ¨™ãƒãƒ¼ã‚«ãƒ¼æç”»
        function drawCoordinateMarker(coord, isDragging = false) {
            const pos = gridType === 'diamond' 
                ? worldToScreen(coord.x + 0.5, coord.y + 0.5)
                : worldToScreen(coord.x + 0.5, coord.y + 0.5);
            const size = Math.min(scale * 0.8, 30);
            
            ctx.fillStyle = isDragging ? '#ff9800' : '#ff4444';
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, size / 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            if (scale > 2) {
                const fontSize = Math.min(scale * 2, 14);
                ctx.font = `bold ${fontSize}px sans-serif`;
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const name = coord.name.length > 10 ? coord.name.substring(0, 10) + '...' : coord.name;
                
                const metrics = ctx.measureText(name);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fillRect(pos.x - metrics.width / 2 - 2, pos.y - fontSize / 2 - 2, metrics.width + 4, fontSize + 4);
                
                ctx.fillStyle = '#000000';
                ctx.fillText(name, pos.x, pos.y);
            }
        }
        
        // åº§æ¨™è§£æ
        function parseCoordinates() {
            const input = document.getElementById('coordInput').value.trim();
            if (!input) {
                alert('åº§æ¨™ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            parsedCoordinates = [];
            
            const customDelim = document.getElementById('customDelimiter').value.trim();
            let entries;
            
            if (customDelim) {
                entries = input.split(customDelim);
            } else {
                entries = input.split(/[\nã€,]/);
            }
            
            entries.forEach((entry, index) => {
                entry = entry.trim();
                if (!entry) return;
                
                let match = entry.match(/^(.+?)[::]?\s*[@@ ]\s*(\d+)\s+(\d+)/);
                if (match) {
                    parsedCoordinates.push({
                        name: match[1].trim().replace(/[::] $/, ''),
                        x: parseInt(match[2]),
                        y: parseInt(match[3])
                    });
                    return;
                }
                
                match = entry.match(/^(\d+)\s+(\d+)/);
                if (match) {
                    parsedCoordinates.push({
                        name: `åº§æ¨™${parsedCoordinates.length + 1}`,
                        x: parseInt(match[1]),
                        y: parseInt(match[2])
                    });
                    return;
                }
            });
            
            if (parsedCoordinates.length === 0) {
                alert('æœ‰åŠ¹ãªåº§æ¨™ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
                return;
            }
            
            alert(`${parsedCoordinates.length}ä»¶ã®åº§æ¨™ã‚’è§£æã—ã¾ã—ãŸ`);
            displayParseResult();
        }
        
        // è§£æçµæœè¡¨ç¤º
        function displayParseResult() {
            const section = document.getElementById('parseResultSection');
            const container = document.getElementById('parseResult');
            
            section.style.display = 'block';
            container.innerHTML = '';
            
            parsedCoordinates.forEach((coord, idx) => {
                const div = document.createElement('div');
                div.className = 'parse-result-item';
                div.innerHTML = `
                    <input type="text" class="name-input" value="${coord.name}" 
                           onchange="updateParsedCoordinate(${idx}, 'name', this.value)">
                    <span>@</span>
                    <input type="number" class="coord-input" value="${coord.x}" min="0" max="700"
                           onchange="updateParsedCoordinate(${idx}, 'x', this.value)">
                    <input type="number" class="coord-input" value="${coord.y}" min="0" max="1900"
                           onchange="updateParsedCoordinate(${idx}, 'y', this.value)">
                `;
                container.appendChild(div);
            });
        }
        
        // è§£ææ¸ˆã¿åº§æ¨™ã®æ›´æ–°
        function updateParsedCoordinate(index, field, value) {
            if (field === 'name') {
                parsedCoordinates[index].name = value;
            } else if (field === 'x') {
                parsedCoordinates[index].x = parseInt(value);
            } else if (field === 'y') {
                parsedCoordinates[index].y = parseInt(value);
            }
        }
        
        // è§£æçµæœã‚’ã‚¯ãƒªã‚¢
        function clearParseResult() {
            parsedCoordinates = [];
            document.getElementById('parseResultSection').style.display = 'none';
            document.getElementById('coordInput').value = '';
        }
        
        // åº§æ¨™ã‚’ä¿å­˜
        function saveCoordinates() {
            if (parsedCoordinates.length === 0) {
                alert('è§£æçµæœãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            const duplicates = [];
            const nonDuplicates = [];
            
            parsedCoordinates.forEach(coord => {
                const isDuplicate = savedCoordinates.some(saved => 
                    saved.x === coord.x && saved.y === coord.y
                );
                if (isDuplicate) {
                    duplicates.push(coord);
                } else {
                    nonDuplicates.push(coord);
                }
            });
            
            if (duplicates.length > 0) {
                const saveAll = confirm(
                    `é‡è¤‡ãƒ‡ãƒ¼ã‚¿ãŒ${duplicates.length}ä»¶ã‚ã‚Šã¾ã™ãŒã€ç™»éŒ²ã‚’è¡Œã„ã¾ã™ã‹?\n` +
                    `(é‡è¤‡ãƒ‡ãƒ¼ã‚¿ã¯ã€ãƒãƒƒãƒ—ã«ã¯è¡¨ç¤ºã›ãšã«ä¿å­˜ã•ã‚Œã¾ã™)`
                );
                
                if (saveAll) {
                    saveCoordsToDatabase(parsedCoordinates, duplicates);
                    clearParseResult();
                } else {
                    const saveNonDuplicates = confirm('é‡è¤‡ãƒ‡ãƒ¼ã‚¿ä»¥å¤–ã®ä¿å­˜ã‚’è¡Œã„ã¾ã™ã‹?');
                    
                    if (saveNonDuplicates) {
                        saveCoordsToDatabase(nonDuplicates, []);
                        
                        parsedCoordinates = duplicates;
                        displayParseResult();
                        
                        alert(`${nonDuplicates.length}ä»¶/${parsedCoordinates.length + nonDuplicates.length}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
                    }
                }
            } else {
                saveCoordsToDatabase(parsedCoordinates, []);
                clearParseResult();
            }
        }
        
        // åº§æ¨™ã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜ã™ã‚‹å†…éƒ¨é–¢æ•°
        function saveCoordsToDatabase(coords, duplicates) {
            const defaultGroup = coordinateGroups.find(g => g.id === 'default');
            
            coords.forEach(coord => {
                const newCoord = {
                    id: Date.now() + Math.random(),
                    name: coord.name,
                    x: coord.x,
                    y: coord.y,
                    createdAt: new Date().toISOString()
                };
                savedCoordinates.push(newCoord);
                
                if (defaultGroup) {
                    defaultGroup.coordinateIds.push(newCoord.id);
                }
                
                const isDuplicate = duplicates.some(d => d.x === coord.x && d.y === coord.y);
                if (isDuplicate) {
                    hiddenCoordinateIds.add(newCoord.id);
                    duplicateCoordinateIds.add(newCoord.id);
                }
            });
            
            updateCoordinatesList();
            updateGroupsList();
            updateStats();
            drawMap();
            
            if (coords.length > 0) {
                alert(`${coords.length}ä»¶ã®åº§æ¨™ã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
            }
        }
        
        // ä¿®æ­£3: ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨ - çµæœ0ä»¶ã®å ´åˆã®è¡¨ç¤ºæ”¹å–„
        function applyFilters() {
            const nameFilter = document.getElementById('nameFilter').value.toLowerCase();
            const dateFrom = document.getElementById('dateFilterFrom').value;
            const dateTo = document.getElementById('dateFilterTo').value;
            const sortBy = document.getElementById('sortBy').value;
            
            filteredCoordinates = savedCoordinates.filter(coord => {
                if (nameFilter && !coord.name.toLowerCase().includes(nameFilter)) {
                    return false;
                }
                
                if (coord.createdAt) {
                    const coordDate = coord.createdAt.split('T')[0];
                    if (dateFrom && coordDate < dateFrom) return false;
                    if (dateTo && coordDate > dateTo) return false;
                }
                
                return true;
            });
            
            filteredCoordinates.sort((a, b) => {
                switch (sortBy) {
                    case 'date-desc':
                        return (b.createdAt || '').localeCompare(a.createdAt || '');
                    case 'date-asc':
                        return (a.createdAt || '').localeCompare(b.createdAt || '');
                    case 'name-asc':
                        return a.name.localeCompare(b.name);
                    case 'name-desc':
                        return b.name.localeCompare(a.name);
                    case 'x-asc':
                        return a.x - b.x;
                    case 'x-desc':
                        return b.x - a.x;
                    case 'y-asc':
                        return a.y - b.y;
                    case 'y-desc':
                        return b.y - a.y;
                    default:
                        return 0;
                }
            });
            
            updateCoordinatesList();
        }
        
        // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚¯ãƒªã‚¢
        function clearFilters() {
            document.getElementById('nameFilter').value = '';
            document.getElementById('dateFilterFrom').value = '';
            document.getElementById('dateFilterTo').value = '';
            document.getElementById('sortBy').value = 'date-desc';
            filteredCoordinates = [];
            groupFilterActive = false;
            expandedGroupId = null;
            updateCoordinatesList();
            updateGroupsList();
        }
        
        // åº§æ¨™ãƒªã‚¹ãƒˆæ›´æ–°
        function updateCoordinatesList() {
            const container = document.getElementById('coordinateList');
            container.innerHTML = '';
            
            // ä¿®æ­£3: ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼çµæœã¾ãŸã¯ã‚°ãƒ«ãƒ¼ãƒ—ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’å„ªå…ˆ
            let displayCoords;
            if (groupFilterActive && expandedGroupId) {
                const group = coordinateGroups.find(g => g.id === expandedGroupId);
                if (group) {
                    displayCoords = savedCoordinates.filter(c => group.coordinateIds.includes(c.id));
                } else {
                    displayCoords = filteredCoordinates.length > 0 ? filteredCoordinates : savedCoordinates;
                }
            } else {
                displayCoords = filteredCoordinates.length > 0 ? filteredCoordinates : savedCoordinates;
            }
            
            // ä¿®æ­£3: æ¤œç´¢çµæœ0ä»¶ã®å ´åˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
            if (displayCoords.length === 0 && (filteredCoordinates.length > 0 || groupFilterActive)) {
                const noResults = document.createElement('div');
                noResults.className = 'no-results-message';
                noResults.textContent = 'è©²å½“ã™ã‚‹åº§æ¨™ãŒã‚ã‚Šã¾ã›ã‚“';
                container.appendChild(noResults);
                return;
            }
            
            if (displayCoords.length > 0) {
                const selectAllDiv = document.createElement('div');
                selectAllDiv.style.cssText = 'background: #e3f2fd; padding: 8px; margin-bottom: 8px; border-radius: 4px;';
                
                const allSelected = displayCoords.every(c => selectedCoordinateIds.has(c.id));
                
                selectAllDiv.innerHTML = `
                    <label style="cursor: pointer; font-weight: bold;">
                        <input type="checkbox" id="selectAllCoords" ${allSelected ? 'checked' : ''} onchange="toggleSelectAllCoordinates(this.checked)">
                        ã™ã¹ã¦é¸æŠ
                    </label>
                `;
                container.appendChild(selectAllDiv);
            }
            
            displayCoords.forEach(coord => {
                const div = document.createElement('div');
                div.className = 'coordinate-item';
                div.style.opacity = hiddenCoordinateIds.has(coord.id) ? '0.5' : '1';
                
                const isSelected = selectedCoordinateIds.has(coord.id);
                const createdDate = new Date(coord.createdAt).toLocaleDateString('ja-JP');
                const createdDateISO = coord.createdAt.split('T')[0];
                const isDuplicate = duplicateCoordinateIds.has(coord.id);
                
                div.innerHTML = `
                    <label style="display: flex; align-items: center; flex: 1;">
                        <input type="checkbox" ${isSelected ? 'checked' : ''} 
                               onchange="toggleCoordinateSelection(${coord.id}, this.checked)" onclick="event.stopPropagation()">
                        <span>
                            <a class="coordinate-name-link" onclick="jumpToCoordinate(${coord.id}); event.stopPropagation();">
                                ${coord.name}: @${coord.x} ${coord.y}
                            </a>
                            ${isDuplicate ? '<span style="color: #ff9800; font-size: 0.9em; margin-left: 4px;">[é‡è¤‡]</span>' : ''}
                            <a class="coordinate-name-link" onclick="filterByDate('${createdDateISO}'); event.stopPropagation();" style="margin-left: 4px;">
                                (${createdDate})
                            </a>
                        </span>
                    </label>
                    <div class="item-actions">
                        <button onclick="editCoordinate(${coord.id}); event.stopPropagation();">âœï¸</button>
                        <button onclick="deleteCoordinate(${coord.id}); event.stopPropagation();" 
                                style="background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);">ğŸ—‘ï¸</button>
                    </div>
                `;
                
                div.onclick = (e) => {
                    if (rangeSelectMode && !e.target.closest('button') && !e.target.closest('input[type="checkbox"]') && !e.target.closest('a')) {
                        handleRangeSelect(coord.id);
                    }
                };
                
                container.appendChild(div);
            });
        }
        
        // åº§æ¨™ã«ã‚¸ãƒ£ãƒ³ãƒ—
        function jumpToCoordinate(id) {
            const coord = savedCoordinates.find(c => c.id === id);
            if (!coord) return;
            
            offsetX = coord.x;
            offsetY = coord.y;
            scale = Math.max(scale, 5);
            drawMap();
        }
        
        // ä¸€ç´šåœ°å¸¯ã«ã‚¸ãƒ£ãƒ³ãƒ—
        function jumpToPrimeZone() {
            offsetX = (primeZone.minX + primeZone.maxX) / 2;
            offsetY = (primeZone.minY + primeZone.maxY) / 2;
            
            const dpr = window.devicePixelRatio || 1;
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;
            
            scale = Math.min(
                width / (primeZone.maxY - primeZone.minY + 20),
                height / (primeZone.maxX - primeZone.minX + 20)
            );
            
            drawMap();
        }
        
        // ä¸€æ‹¬é¸æŠãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆ
        function toggleRangeSelectMode() {
            rangeSelectMode = document.getElementById('rangeSelectMode').checked;
            rangeSelectStart = null;
        }
        
        // ç¯„å›²é¸æŠå‡¦ç†
        function handleRangeSelect(coordinateId) {
            if (!rangeSelectStart) {
                rangeSelectStart = coordinateId;
                if (selectedCoordinateIds.has(coordinateId)) {
                    selectedCoordinateIds.delete(coordinateId);
                } else {
                    selectedCoordinateIds.add(coordinateId);
                }
            } else {
                if (rangeSelectStart === coordinateId) {
                    if (selectedCoordinateIds.has(coordinateId)) {
                        selectedCoordinateIds.delete(coordinateId);
                    }
                    rangeSelectStart = null;
                } else {
                    const displayCoords = filteredCoordinates.length > 0 ? filteredCoordinates : savedCoordinates;
                    const startIndex = displayCoords.findIndex(c => c.id === rangeSelectStart);
                    const endIndex = displayCoords.findIndex(c => c.id === coordinateId);
                    
                    const minIndex = Math.min(startIndex, endIndex);
                    const maxIndex = Math.max(startIndex, endIndex);
                    
                    for (let i = minIndex; i <= maxIndex; i++) {
                        selectedCoordinateIds.add(displayCoords[i].id);
                    }
                    
                    rangeSelectStart = null;
                }
            }
            
            updateCoordinatesList();
            updateStats();
        }
        
        // åº§æ¨™é¸æŠãƒˆã‚°ãƒ«
        function toggleCoordinateSelection(id, checked) {
            if (checked) {
                selectedCoordinateIds.add(id);
            } else {
                selectedCoordinateIds.delete(id);
            }
            updateStats();
        }
        
        // ã™ã¹ã¦ã®åº§æ¨™é¸æŠãƒˆã‚°ãƒ«
        function toggleSelectAllCoordinates(checked) {
            const displayCoords = filteredCoordinates.length > 0 ? filteredCoordinates : savedCoordinates;
            if (checked) {
                displayCoords.forEach(c => selectedCoordinateIds.add(c.id));
            } else {
                displayCoords.forEach(c => selectedCoordinateIds.delete(c.id));
            }
            updateCoordinatesList();
            updateStats();
        }
        
        // é¸æŠæ¸ˆã¿åº§æ¨™ã‚’éè¡¨ç¤º
        function hideSelectedCoordinates() {
            if (selectedCoordinateIds.size === 0) {
                alert('åº§æ¨™ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            selectedCoordinateIds.forEach(id => hiddenCoordinateIds.add(id));
            updateCoordinatesList();
            drawMap();
        }
        
        // ã™ã¹ã¦ã®åº§æ¨™ã‚’è¡¨ç¤º
        function showAllCoordinates() {
            hiddenCoordinateIds.clear();
            updateCoordinatesList();
            drawMap();
        }
        
        // é‡è¤‡åº§æ¨™ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
        function toggleDuplicateCoordinates() {
            const btn = document.getElementById('toggleDuplicateBtn');
            
            const allDuplicatesHidden = Array.from(duplicateCoordinateIds).every(id => hiddenCoordinateIds.has(id));
            
            if (allDuplicatesHidden) {
                duplicateCoordinateIds.forEach(id => {
                    hiddenCoordinateIds.delete(id);
                });
                btn.textContent = 'ğŸ‘ï¸ é‡è¤‡åº§æ¨™ã‚’éè¡¨ç¤º';
            } else {
                duplicateCoordinateIds.forEach(id => {
                    hiddenCoordinateIds.add(id);
                });
                btn.textContent = 'ğŸ‘ï¸ é‡è¤‡åº§æ¨™ã‚’è¡¨ç¤º';
            }
            
            updateCoordinatesList();
            drawMap();
        }
        
        // é¸æŠåº§æ¨™ã®å‰Šé™¤
        function deleteSelectedCoordinates() {
            if (selectedCoordinateIds.size === 0) {
                alert('åº§æ¨™ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            if (confirm(`é¸æŠã•ã‚ŒãŸ${selectedCoordinateIds.size}ä»¶ã®åº§æ¨™ã‚’å‰Šé™¤ã—ã¾ã™ã‹?`)) {
                savedCoordinates = savedCoordinates.filter(c => !selectedCoordinateIds.has(c.id));
                
                coordinateGroups.forEach(group => {
                    group.coordinateIds = group.coordinateIds.filter(id => !selectedCoordinateIds.has(id));
                });
                
                selectedCoordinateIds.forEach(id => {
                    duplicateCoordinateIds.delete(id);
                    hiddenCoordinateIds.delete(id);
                });
                
                selectedCoordinateIds.clear();
                updateCoordinatesList();
                updateGroupsList();
                updateStats();
                drawMap();
            }
        }
        
        // åº§æ¨™ç·¨é›†
        function editCoordinate(id) {
            const coord = savedCoordinates.find(c => c.id === id);
            if (!coord) return;
            
            const newName = prompt('æ–°ã—ã„åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:', coord.name);
            if (newName) {
                coord.name = newName;
                updateCoordinatesList();
            }
        }
        
        // åº§æ¨™å‰Šé™¤
        function deleteCoordinate(id) {
            const coord = savedCoordinates.find(c => c.id === id);
            if (!coord) return;
            
            if (confirm(`${coord.name} ã‚’å‰Šé™¤ã—ã¾ã™ã‹?`)) {
                savedCoordinates = savedCoordinates.filter(c => c.id !== id);
                selectedCoordinateIds.delete(id);
                hiddenCoordinateIds.delete(id);
                duplicateCoordinateIds.delete(id);
                
                coordinateGroups.forEach(group => {
                    group.coordinateIds = group.coordinateIds.filter(cid => cid !== id);
                });
                
                updateCoordinatesList();
                updateGroupsList();
                updateStats();
                drawMap();
            }
        }
        
        // ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆ
        function createGroup() {
            const name = document.getElementById('groupName').value.trim();
            if (!name) {
                alert('ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            coordinateGroups.push({
                id: Date.now().toString(),
                name: name,
                coordinateIds: Array.from(selectedCoordinateIds),
                createdAt: new Date().toISOString()
            });
            
            document.getElementById('groupName').value = '';
            selectedCoordinateIds.clear();
            
            updateCoordinatesList();
            updateGroupsList();
            updateStats();
        }
        
        // ä¿®æ­£8: ã‚°ãƒ«ãƒ¼ãƒ—ãƒªã‚¹ãƒˆæ›´æ–° - ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³å¼
        function updateGroupsList() {
            const container = document.getElementById('groupList');
            container.innerHTML = '';
            
            coordinateGroups.forEach(group => {
                const div = document.createElement('div');
                div.className = 'group-item' + (expandedGroupId === group.id ? ' expanded' : '');
                
                const headerDiv = document.createElement('div');
                headerDiv.className = 'group-header';
                headerDiv.onclick = () => toggleGroupExpansion(group.id);
                headerDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; width: 100%;';
                
                headerDiv.innerHTML = `
                    <span style="display: flex; align-items: center; flex: 1;">
                        <span class="group-expand-icon">â–¶</span>
                        <strong>${group.name}</strong> (${group.coordinateIds.length}ä»¶)
                    </span>
                    <div class="item-actions" onclick="event.stopPropagation();">
                        <button onclick="selectGroupCoordinates('${group.id}')">é¸æŠ</button>
                        <button onclick="addCoordinatesToGroup('${group.id}')" style="background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);">â•è¿½åŠ </button>
                        <button onclick="editGroup('${group.id}')">âœï¸</button>
                        <button onclick="deleteGroup('${group.id}')" 
                                style="background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);">ğŸ—‘ï¸</button>
                    </div>
                `;
                
                div.appendChild(headerDiv);
                
                // ä¿®æ­£8: åº§æ¨™ãƒªã‚¹ãƒˆã®å±•é–‹
                const coordsDiv = document.createElement('div');
                coordsDiv.className = 'group-coordinates';
                
                const groupCoords = savedCoordinates.filter(c => group.coordinateIds.includes(c.id));
                groupCoords.forEach(coord => {
                    const coordItem = document.createElement('div');
                    coordItem.className = 'group-coord-item';
                    coordItem.textContent = `${coord.name}: @${coord.x} ${coord.y}`;
                    coordItem.onclick = () => jumpToCoordinate(coord.id);
                    coordsDiv.appendChild(coordItem);
                });
                
                div.appendChild(coordsDiv);
                container.appendChild(div);
            });
        }
        
        // ä¿®æ­£8: ã‚°ãƒ«ãƒ¼ãƒ—å±•é–‹ãƒˆã‚°ãƒ«
        function toggleGroupExpansion(groupId) {
            if (expandedGroupId === groupId) {
                // åŒã˜ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ã‚¯ãƒªãƒƒã‚¯: é–‰ã˜ã‚‹
                expandedGroupId = null;
                groupFilterActive = false;
            } else {
                // åˆ¥ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ã‚¯ãƒªãƒƒã‚¯: é–‹ã
                expandedGroupId = groupId;
                groupFilterActive = true;
            }
            
            updateGroupsList();
            updateCoordinatesList();
        }
        
        // ã‚°ãƒ«ãƒ¼ãƒ—ã«åº§æ¨™ã‚’è¿½åŠ 
        function addCoordinatesToGroup(groupId) {
            const group = coordinateGroups.find(g => g.id === groupId);
            if (!group) return;
            
            if (selectedCoordinateIds.size === 0) {
                alert('åº§æ¨™ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            let addedCount = 0;
            let skippedCount = 0;
            
            selectedCoordinateIds.forEach(id => {
                if (!group.coordinateIds.includes(id)) {
                    group.coordinateIds.push(id);
                    addedCount++;
                } else {
                    skippedCount++;
                }
            });
            
            updateGroupsList();
            updateStats();
            
            alert(`${addedCount}ä»¶ã®åº§æ¨™ã‚’ã€Œ${group.name}ã€ã«è¿½åŠ ã—ã¾ã—ãŸã€‚\n(æ—¢ã«å«ã¾ã‚Œã¦ã„ãŸåº§æ¨™:${skippedCount}ä»¶)`);
        }
        
        // ã‚°ãƒ«ãƒ¼ãƒ—ã®åº§æ¨™ã‚’é¸æŠ
        function selectGroupCoordinates(groupId) {
            const group = coordinateGroups.find(g => g.id === groupId);
            if (!group) return;
            
            selectedCoordinateIds.clear();
            group.coordinateIds.forEach(id => {
                if (savedCoordinates.find(c => c.id === id)) {
                    selectedCoordinateIds.add(id);
                }
            });
            
            updateCoordinatesList();
            updateStats();
        }
        
        // ã‚°ãƒ«ãƒ¼ãƒ—ç·¨é›†
        function editGroup(groupId) {
            const group = coordinateGroups.find(g => g.id === groupId);
            if (!group) return;
            
            const newName = prompt('æ–°ã—ã„ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:', group.name);
            if (newName) {
                group.name = newName;
                updateGroupsList();
            }
        }
        
        // ã‚°ãƒ«ãƒ¼ãƒ—å‰Šé™¤
        function deleteGroup(groupId) {
            if (groupId === 'default') {
                alert('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚°ãƒ«ãƒ¼ãƒ—ã¯å‰Šé™¤ã§ãã¾ã›ã‚“');
                return;
            }
            
            if (confirm('ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å‰Šé™¤ã—ã¾ã™ã‹?(åº§æ¨™è‡ªä½“ã¯å‰Šé™¤ã•ã‚Œã¾ã›ã‚“)')) {
                coordinateGroups = coordinateGroups.filter(g => g.id !== groupId);
                if (expandedGroupId === groupId) {
                    expandedGroupId = null;
                    groupFilterActive = false;
                }
                updateGroupsList();
                updateCoordinatesList();
                updateStats();
            }
        }
        
        // éšœå®³ç‰©ã‚¿ã‚¤ãƒ—é¸æŠ
        function selectObstacleType(type) {
            if (currentMode !== 'input' && currentMode !== 'delete') {
                alert('å…¥åŠ›ãƒ¢ãƒ¼ãƒ‰ã¾ãŸã¯å‰Šé™¤ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            selectedObstacleType = selectedObstacleType === type ? null : type;
            
            document.querySelectorAll('.obstacle-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            if (selectedObstacleType) {
                const btnId = type === 'rock' ? 'obstacleRock' : `obstacle_${type}`;
                const btn = document.getElementById(btnId);
                if (btn) btn.classList.add('selected');
            }
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ãƒ•ã‚©ãƒ¼ãƒ è¡¨ç¤º
        function showCustomObstacleForm() {
            document.getElementById('customObstacleFormContainer').style.display = 'block';
            isCreatingCustomObstacle = false;
            customObstacleInProgress = null;
            document.getElementById('tempShapeMessage').style.display = 'none';
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ãƒ•ã‚©ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        function cancelCustomObstacleForm() {
            document.getElementById('customObstacleFormContainer').style.display = 'none';
            document.getElementById('customObstacleName').value = '';
            isCreatingCustomObstacle = false;
            customObstacleInProgress = null;
            tempSelection.clear();
            document.getElementById('tempShapeMessage').style.display = 'none';
            drawMap();
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ä½œæˆ
        function createCustomObstacle() {
            const name = document.getElementById('customObstacleName').value.trim();
            const placementType = document.getElementById('customObstaclePlacementType').value;
            const color = getSelectedColor();
            
            if (!name) {
                alert('éšœå®³ç‰©åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            if (placementType === 'tap') {
                if (!isCreatingCustomObstacle) {
                    isCreatingCustomObstacle = true;
                    customObstacleInProgress = {
                        name: name,
                        color: color,
                        placementType: placementType
                    };
                    
                    document.getElementById('tempShapeMessage').style.display = 'block';
                    changeMode('input');
                    selectedObstacleType = 'temp_custom';
                    return;
                } else {
                    if (tempSelection.size === 0) {
                        alert('éšœå®³ç‰©ã®å½¢çŠ¶ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                        return;
                    }
                    
                    const customId = `custom_${Date.now()}`;
                    
                    const firstKey = Array.from(tempSelection)[0];
                    const [fx, fy] = firstKey.split(',').map(Number);
                    const shape = Array.from(tempSelection).map(key => {
                        const [x, y] = key.split(',').map(Number);
                        return `${x - fx},${y - fy}`;
                    });
                    
                    customObstacles.push({
                        id: customId,
                        name: name,
                        color: customObstacleInProgress.color,
                        shape: shape
                    });
                    
                    tempSelection.clear();
                    
                    updateCustomObstacleButtons();
                    cancelCustomObstacleForm();
                    updateStats();
                    drawMap();
                    
                    alert(`ç”Ÿæˆã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ å½¢çŠ¶ã‚’ã€åç§°ã€Œ${name}ã€ã¨ã—ã¦ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä¿ç®¡ã—ã€ãƒãƒƒãƒ—ä¸Šã«ç”Ÿæˆã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã¯ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚\néšœå®³ç‰©ç®¡ç†æ¬„ã‹ã‚‰ä½¿ç”¨å¯èƒ½ã§ã™ã€‚`);
                    return;
                }
            }
            
            const customId = `custom_${Date.now()}`;
            customObstacles.push({
                id: customId,
                name: name,
                color: color,
                shape: ['0,0']
            });
            
            updateCustomObstacleButtons();
            cancelCustomObstacleForm();
            
            alert(`ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ã€Œ${name}ã€ã‚’ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã¨ã—ã¦ä½œæˆã—ã¾ã—ãŸã€‚\néšœå®³ç‰©ç®¡ç†æ¬„ã‹ã‚‰ä½¿ç”¨å¯èƒ½ã§ã™ã€‚`);
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ éšœå®³ç‰©ãƒœã‚¿ãƒ³ã‚’æ›´æ–°
        function updateCustomObstacleButtons() {
            const container = document.getElementById('customObstacleButtons');
            container.innerHTML = '';
            
            customObstacles.forEach(obstacle => {
                const div = document.createElement('div');
                div.className = 'custom-obstacle-display';
                
                const displayColor = obstacle.color;
                
                div.innerHTML = `
                    <div class="color-swatch" style="background-color: ${displayColor}"></div>
                    <button onclick="selectObstacleType('${obstacle.id}')" class="obstacle-btn" id="obstacle_${obstacle.id}" style="flex: 1;">
                        ${obstacle.name}
                    </button>
                `;
                container.appendChild(div);
            });
        }
        
        // éšœå®³ç‰©ã®ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
        function groupObstacles() {
            const typeGroups = {};
            
            obstacles.forEach(obstacle => {
                if (!typeGroups[obstacle.type]) {
                    typeGroups[obstacle.type] = [];
                }
                obstacle.cells.forEach(cell => {
                    typeGroups[obstacle.type].push(cell);
                });
            });
            
            obstacles = [];
            
            for (const [type, cells] of Object.entries(typeGroups)) {
                const visited = new Set();
                const cellSet = new Set(cells);
                
                cells.forEach(cell => {
                    if (visited.has(cell)) return;
                    
                    const component = [];
                    const queue = [cell];
                    
                    while (queue.length > 0) {
                        const current = queue.shift();
                        if (visited.has(current)) continue;
                        
                        visited.add(current);
                        component.push(current);
                        
                        const [x, y] = current.split(',').map(Number);
                        const neighbors = [
                            `${x+1},${y}`,
                            `${x-1},${y}`,
                            `${x},${y+1}`,
                            `${x},${y-1}`
                        ];
                        
                        neighbors.forEach(neighbor => {
                            if (cellSet.has(neighbor) && !visited.has(neighbor)) {
                                queue.push(neighbor);
                            }
                        });
                    }
                    
                    if (component.length > 0) {
                        obstacles.push({
                            id: Date.now() + Math.random(),
                            type: type,
                            cells: component
                        });
                    }
                });
            }
        }
        
        // éšœå®³ç‰©ãƒªã‚¹ãƒˆæ›´æ–°
        function updateObstaclesList() {
            const container = document.getElementById('obstacleList');
            container.innerHTML = '';
            
            if (obstacles.length > 0) {
                const selectAllDiv = document.createElement('div');
                selectAllDiv.style.cssText = 'background: #e3f2fd; padding: 8px; margin-bottom: 8px; border-radius: 4px;';
                selectAllDiv.innerHTML = `
                    <label style="cursor: pointer; font-weight: bold;">
                        <input type="checkbox" id="selectAllObstacles" onchange="toggleSelectAllObstacles(this.checked)">
                        ã™ã¹ã¦é¸æŠ
                    </label>
                `;
                container.appendChild(selectAllDiv);
            }
            
            obstacles.forEach((obstacle, index) => {
                const div = document.createElement('div');
                div.className = 'obstacle-item';
                
                let obstacleName = obstacleNames[obstacle.type] || obstacle.type;
                const customObstacle = customObstacles.find(o => o.id === obstacle.type);
                if (customObstacle) {
                    obstacleName = customObstacle.name;
                }
                
                div.innerHTML = `
                    <label style="display: flex; align-items: center; flex: 1; cursor: pointer;">
                        <input type="checkbox" ${selectedObstacleIds.has(obstacle.id) ? 'checked' : ''} 
                               onchange="toggleObstacleSelection(${obstacle.id}, this.checked)">
                        <span>${obstacleName} #${index + 1} (${obstacle.cells.length}ãƒã‚¹)</span>
                    </label>
                    <div class="item-actions">
                        <button onclick="deleteObstacleItem(${obstacle.id})" 
                                style="background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);">ğŸ—‘ï¸</button>
                    </div>
                `;
                container.appendChild(div);
            });
        }
        
        // ã™ã¹ã¦ã®éšœå®³ç‰©ã‚’é¸æŠ/è§£é™¤
        function toggleSelectAllObstacles(checked) {
            if (checked) {
                obstacles.forEach(o => selectedObstacleIds.add(o.id));
            } else {
                selectedObstacleIds.clear();
            }
            updateObstaclesList();
        }
        
        // éšœå®³ç‰©ã®é¸æŠãƒˆã‚°ãƒ«
        function toggleObstacleSelection(id, checked) {
            if (checked) {
                selectedObstacleIds.add(id);
            } else {
                selectedObstacleIds.delete(id);
            }
        }
        
        // éšœå®³ç‰©ã‚¢ã‚¤ãƒ†ãƒ ã®å‰Šé™¤
        function deleteObstacleItem(id) {
            if (confirm('ã“ã®éšœå®³ç‰©ã‚’å‰Šé™¤ã—ã¾ã™ã‹?')) {
                obstacles = obstacles.filter(o => o.id !== id);
                selectedObstacleIds.delete(id);
                updateObstaclesList();
                updateStats();
                drawMap();
            }
        }
        
        // é¸æŠã•ã‚ŒãŸéšœå®³ç‰©ã®å‰Šé™¤
        function deleteSelectedObstacles() {
            if (selectedObstacleIds.size === 0) {
                alert('éšœå®³ç‰©ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            if (confirm(`é¸æŠã•ã‚ŒãŸ${selectedObstacleIds.size}ä»¶ã®éšœå®³ç‰©ã‚’å‰Šé™¤ã—ã¾ã™ã‹?`)) {
                obstacles = obstacles.filter(o => !selectedObstacleIds.has(o.id));
                selectedObstacleIds.clear();
                updateObstaclesList();
                updateStats();
                drawMap();
            }
        }
        
        // ã‚ºãƒ¼ãƒ 
        function zoomIn() {
            scale = Math.min(scale * 1.5, 20);
            drawMap();
        }
        
        function zoomOut() {
            scale = Math.max(scale / 1.5, 0.5);
            drawMap();
        }
        
        // ãƒ‡ãƒ¼ã‚¿å‡ºåŠ›
        function exportData() {
            let text = '=== åº§æ¨™ãƒ‡ãƒ¼ã‚¿ ===\n';
            savedCoordinates.forEach(coord => {
                text += `${coord.name}@${coord.x} ${coord.y}\n`;
            });
            
            text += '\n=== ã‚°ãƒ«ãƒ¼ãƒ— ===\n';
            coordinateGroups.forEach(group => {
                const coords = savedCoordinates.filter(c => group.coordinateIds.includes(c.id));
                text += `\n[${group.name}]\n`;
                coords.forEach(coord => {
                    text += `${coord.name}@${coord.x} ${coord.y}\n`;
                });
            });
            
            text += '\n=== éšœå®³ç‰© ===\n';
            obstacles.forEach((obstacle, index) => {
                let obstacleName = obstacleNames[obstacle.type] || obstacle.type;
                const customObstacle = customObstacles.find(o => o.id === obstacle.type);
                if (customObstacle) {
                    obstacleName = customObstacle.name;
                }
                text += `${obstacleName} #${index + 1}: ${obstacle.cells.length}ãƒã‚¹\n`;
            });
            
            downloadTextFile(text, 'map_data.txt');
        }
        
        // ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
        function downloadTextFile(text, filename) {
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // ä¿®æ­£2: å…¨ç”»é¢è¡¨ç¤ºã®åˆ‡ã‚Šæ›¿ãˆ - ãƒªã‚µã‚¤ã‚ºå‡¦ç†ã®æ”¹å–„
        function toggleFullscreen() {
            const section = document.querySelector('.top-panel > .section');
            const btn = document.getElementById('fullscreenBtn');
            
            if (!document.fullscreenElement) {
                section.requestFullscreen().then(() => {
                    section.classList.add('fullscreen-container');
                    btn.textContent = 'âœ• å…¨ç”»é¢è§£é™¤';
                    
                    // ä¿®æ­£2: å…¨ç”»é¢è¡¨ç¤ºæ™‚ã®ãƒªã‚µã‚¤ã‚ºã‚’å¼·åˆ¶å®Ÿè¡Œ
                    setTimeout(() => {
                        resizeCanvas();
                        drawMap();
                    }, 100);
                }).catch(err => {
                    alert('å…¨ç”»é¢è¡¨ç¤ºã«å¤±æ•—ã—ã¾ã—ãŸ: ' + err.message);
                });
            } else {
                document.exitFullscreen().then(() => {
                    section.classList.remove('fullscreen-container');
                    btn.textContent = 'ğŸ–¼ï¸ å…¨ç”»é¢è¡¨ç¤º';
                    
                    // ä¿®æ­£2: å…¨ç”»é¢è§£é™¤æ™‚ã®ãƒªã‚µã‚¤ã‚ºã‚’å¼·åˆ¶å®Ÿè¡Œ
                    setTimeout(() => {
                        resizeCanvas();
                        drawMap();
                    }, 100);
                });
            }
        }
        
        // å…¨ç”»é¢è¡¨ç¤ºã®å¤‰æ›´ã‚’ç›£è¦–
        document.addEventListener('fullscreenchange', () => {
            const section = document.querySelector('.top-panel > .section');
            const btn = document.getElementById('fullscreenBtn');
            if (!document.fullscreenElement) {
                section.classList.remove('fullscreen-container');
                btn.textContent = 'ğŸ–¼ï¸ å…¨ç”»é¢è¡¨ç¤º';
                resizeCanvas();
            }
        });
        
        // ä¿®æ­£4: çµ±è¨ˆã®æ›´æ–° - å±…ä½ç¯„å›²å æœ‰ç‡ã®è¿½åŠ 
        function updateStats() {
            document.getElementById('coordCount').textContent = savedCoordinates.length;
            document.getElementById('obstacleCount').textContent = obstacles.length;
            document.getElementById('groupCount').textContent = coordinateGroups.length;
            document.getElementById('selectedCount').textContent = selectedCoordinateIds.size;
            
            // ä¿®æ­£4: å±…ä½ç¯„å›²å æœ‰ç‡ã®è¨ˆç®—
            const primeZoneTotalCells = (primeZone.maxX - primeZone.minX + 1) * (primeZone.maxY - primeZone.minY + 1);
            
            // éšœå®³ç‰©ã®ãƒã‚¹æ•°ã‚’è¨ˆç®—(ä¸€ç´šåœ°å¸¯å†…ã®ã¿)
            let obstacleCells = new Set();
            obstacles.forEach(obstacle => {
                obstacle.cells.forEach(cell => {
                    const [x, y] = cell.split(',').map(Number);
                    if (x >= primeZone.minX && x <= primeZone.maxX && 
                        y >= primeZone.minY && y <= primeZone.maxY) {
                        obstacleCells.add(cell);
                    }
                });
            });
            
            // åŸã®ãƒã‚¹æ•°ã‚’è¨ˆç®—(ä¸€ç´šåœ°å¸¯å†…ã®ã¿)
            let castleCells = new Set();
            castles.forEach(castle => {
                for (let dx = -8; dx <= 8; dx++) {
                    for (let dy = -8; dy <= 8; dy++) {
                        const x = castle.x + dx;
                        const y = castle.y + dy;
                        if (x >= primeZone.minX && x <= primeZone.maxX && 
                            y >= primeZone.minY && y <= primeZone.maxY) {
                            castleCells.add(`${x},${y}`);
                        }
                    }
                }
            });
            
            // åˆ©ç”¨å¯èƒ½ãƒã‚¹æ•° = ä¸€ç´šåœ°å¸¯å…¨ä½“ - éšœå®³ç‰© - åŸ
            const availableCells = primeZoneTotalCells - obstacleCells.size - castleCells.size;
            
            // å±…ä½ç¯„å›²ã®ãƒã‚¹æ•°ã‚’è¨ˆç®—(ä¸€ç´šåœ°å¸¯å†…ã€ã‹ã¤è¡¨ç¤ºä¸­ã®åº§æ¨™ã®ã¿)
            let residenceCells = new Set();
            savedCoordinates.forEach(coord => {
                if (hiddenCoordinateIds.has(coord.id)) return;
                
                for (let dx = -10; dx <= 10; dx++) {
                    for (let dy = -10; dy <= 10; dy++) {
                        const x = coord.x + dx;
                        const y = coord.y + dy;
                        if (x >= primeZone.minX && x <= primeZone.maxX && 
                            y >= primeZone.minY && y <= primeZone.maxY) {
                            residenceCells.add(`${x},${y}`);
                        }
                    }
                }
            });
            
            // å æœ‰ç‡ã‚’è¨ˆç®—
            const occupancyRate = availableCells > 0 ? (residenceCells.size / availableCells * 100).toFixed(1) : 0;
            document.getElementById('occupancyRate').textContent = `${occupancyRate}%`;
        }
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«åˆæœŸåŒ–
        window.addEventListener('load', init);
    </script>
</body>
</html>
